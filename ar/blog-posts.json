[
  {
    "id": "ecommerce-growth",
    "link": "posts/ecommerce-growth/",
    "title": "5 طرق يمكن لتحليل البيانات أن يزيد أرباح المتاجر الإلكترونية",
    "date": "11 أغسطس 2025",
    "readTime": "6 دقائق",
    "tags": ["التجارة الإلكترونية", "تحليل بيانات"],
    "image": "assets/images/store.png",
    "excerpt": "اكتشف كيف يمكن لتحليل سلوك العملاء، تحسين الأسعار، وإدارة المخزون بذكاء أن يكون سلاحك السري لزيادة الأرباح وتحقيق النمو المستدام.",
    "author": {
      "name": "عمر بدر",
      "linkedin": "https://www.linkedin.com/in/omarbadrdata/",
      "avatar": "assets/images/profile.jpg"
    },
    "content": "<p>في عالم التجارة الإلكترونية شديد التنافسية، لم يعد النجاح يعتمد على جودة المنتج فقط، بل على مدى فهمك لبياناتك. البيانات هي النفط الجديد، وتحليلها هو مفتاح النمو المستدام. في هذا المقال، سأستعرض خمس طرق عملية ومباشرة يمكن لتحليل البيانات من خلالها أن يساهم في زيادة أرباح متجرك الإلكتروني.</p><h2>1. تقسيم العملاء (Customer Segmentation )</h2><p>ليس كل العملاء سواسية. باستخدام نماذج مثل RFM (Recency, Frequency, Monetary)، يمكنك تقسيم عملائك إلى شرائح استراتيجية: العملاء الأبطال (Champions)، العملاء الأوفياء، العملاء المعرضون للخطر، وغيرهم. هذا يمكنك من:</p><ul><li>إطلاق حملات تسويقية مخصصة لكل شريحة.</li><li>تقديم عروض حصرية للعملاء الأكثر قيمة لزيادة ولائهم.</li><li>إعادة استهداف العملاء الخاملين بعروض لا يمكن مقاومتها.</li></ul><h2>2. تحليل سلة المشتريات (Market Basket Analysis)</h2><p>هل تساءلت يوماً ما هي المنتجات التي يشتريها العملاء معاً؟ تحليل سلة المشتريات يجيب على هذا السؤال. من خلال فهم هذه العلاقات، يمكنك:</p><ul><li>عرض توصيات ذكية للمنتجات (Products you may also like).</li><li>إنشاء حزم وعروض (Bundles) تزيد من متوسط قيمة الطلب (Average Order Value).</li><li>تحسين تصميم صفحات المنتجات لعرض المنتجات ذات الصلة.</li></ul><h2>3. التسعير الديناميكي (Dynamic Pricing)</h2><p>بدلاً من تحديد سعر ثابت، يمكنك استخدام البيانات لتعديل الأسعار بشكل ديناميكي بناءً على عوامل مثل الطلب، أسعار المنافسين، الوقت من اليوم، وحتى سلوك المستخدم. هذا لا يعني رفع الأسعار دائماً، بل تحديد السعر الأمثل الذي يحقق أقصى ربح في كل لحظة.</p><h2>4. التنبؤ بالمخزون (Inventory Forecasting)</h2><p>نفاد المخزون يعني خسارة مبيعات، وزيادة المخزون تعني تجميد رأس المال. باستخدام بيانات المبيعات التاريخية، يمكن بناء نماذج تنبؤية تتوقع حجم الطلب على كل منتج، مما يساعدك على إدارة مخزونك بكفاءة وتجنب كلتا المشكلتين.</p><h2>5. تحليل مسار التحويل (Conversion Funnel Analysis)</h2><p>لماذا يضيف العملاء منتجات إلى السلة ثم يغادرون دون شراء؟ تحليل مسار التحويل (من زيارة الصفحة الرئيسية إلى إتمام الدفع) يساعدك على تحديد نقاط الضعف في موقعك. قد تكتشف أن عملية الدفع معقدة، أو أن تكاليف الشحن غير واضحة. إصلاح هذه النقاط يمكن أن يرفع معدل التحويل بشكل كبير.</p><hr><h3>الخلاصة</h3><p>تحليل البيانات لم يعد ترفاً، بل هو ضرورة حتمية لنجاح أي متجر إلكتروني. البدء في تطبيق هذه الاستراتيجيات سيمنحك ميزة تنافسية قوية ويضعك على الطريق الصحيح لتحقيق نمو حقيقي ومستدام.</p><p><strong>هل أنت مستعد للبدء؟ <a href='https://www.omarbadrdata.foo/ar/contact/'>تواصل معي</a> لمناقشة كيف يمكننا تطبيق هذه الحلول على متجرك.</strong></p>"
  },
  {
    "id": "heart-disease-prediction",
    "link": "posts/heart-disease-prediction/",
    "title": "شرح مبسط: كيف يعمل نموذج التنبؤ بأمراض القلب؟",
    "date": "11 2025 أغسطس",
    "readTime": "5 دقائق",
    "tags": ["تعلم الآلة", "شروحات"],
    "image": "assets/images/heart.png",
    "excerpt": "نظرة من الداخل على كيفية استخدام الخوارزميات لتحليل العوامل الطبية والتنبؤ بالمخاطر الصحية، بدون مصطلحات معقدة.",
    "author": {
      "name": "عمر بدر",
      "linkedin": "https://www.linkedin.com/in/omarbadrdata/",
      "avatar": "assets/images/profile.jpg"
    },
    "content": "<p>في عالم الطب الحديث، أصبح الذكاء الاصطناعي وتحليل البيانات يلعبان دوراً محورياً في تحسين الرعاية الصحية. أحد أهم التطبيقات هو نماذج التنبؤ بأمراض القلب، التي تساعد الأطباء على اكتشاف المرض قبل حدوثه. في هذا المقال، سأشرح لك بطريقة مبسطة كيف يعمل نموذج التنبؤ بأمراض القلب.</p><h2>1. جمع البيانات الطبية</h2><p>الخطوة الأولى هي جمع بيانات المرضى من مصادر متعددة مثل:</p><ul><li>تحاليل الدم ومستوى الكوليسترول.</li><li>ضغط الدم ومعدل ضربات القلب.</li><li>العمر، الجنس، والتاريخ العائلي للأمراض القلبية.</li><li>نمط الحياة (التدخين، النشاط البدني، النظام الغذائي).</li></ul><h2>2. معالجة وتنظيف البيانات</h2><p>البيانات الطبية غالباً ما تحتوي على معلومات ناقصة أو غير دقيقة. يقوم محللو البيانات بتنظيف هذه البيانات، وإزالة القيم الشاذة، وتحويلها إلى صيغة قابلة للاستخدام في النماذج الإحصائية أو خوارزميات التعلم الآلي.</p><h2>3. اختيار الخوارزمية المناسبة</h2><p>هناك عدة خوارزميات يمكن استخدامها، مثل:</p><ul><li>Logistic Regression (الانحدار اللوجستي).</li><li>Decision Trees (أشجار القرار).</li><li>Random Forest أو Gradient Boosting.</li><li>الشبكات العصبية الاصطناعية (Neural Networks) في الحالات الأكثر تعقيداً.</li></ul><h2>4. تدريب النموذج</h2><p>يتم تقسيم البيانات إلى مجموعتين: بيانات التدريب وبيانات الاختبار. يتعلم النموذج من بيانات التدريب العلاقة بين العوامل الصحية واحتمالية الإصابة بأمراض القلب.</p><h2>5. التنبؤ وتقييم الأداء</h2><p>بعد التدريب، يُستخدم النموذج للتنبؤ على بيانات جديدة. ثم يتم تقييم دقته باستخدام مقاييس مثل:</p><ul><li>الدقة (Accuracy).</li><li>المعامل F1 (F1-Score).</li><li>منحنى ROC و AUC.</li></ul><hr><h3>الخلاصة</h3><p>نموذج التنبؤ بأمراض القلب هو أداة قوية تساعد على الوقاية المبكرة وتحسين فرص العلاج. يعتمد نجاحه على جودة البيانات ودقة تصميمه. استخدام هذه النماذج يمكن أن ينقذ الأرواح ويقلل من تكلفة الرعاية الصحية.</p><p><strong>هل ترغب في معرفة كيف يمكننا بناء نموذج مخصص لك أو لمؤسستك الطبية؟ <a href='https://www.omarbadrdata.foo/ar/contact/'>تواصل معي</a> لنبدأ العمل.</strong></p>"
  },
  {
    "id": "python-humanize-package",
    "link": "posts/python-humanize-package/",
    "title": "شرح مبسط: كيف تستخدم مكتبة Humanize في بايثون؟",
    "date": "11 أغسطس 2025",
    "readTime": "7 دقائق",
    "tags": ["بايثون", "شروحات", "مكتبات"],
    "image": "assets/images/python_humanize.png",
    "excerpt": "اكتشف كيف يمكن لمكتبة Humanize تحويل البيانات التقنية مثل الأرقام، التواريخ، وحجم الملفات إلى نصوص سهلة القراءة والفهم للبشر.",
    "author": {
      "name": "عمر بدر",
      "linkedin": "https://www.linkedin.com/in/omarbadrdata/",
      "avatar": "assets/images/profile.jpg"
    },
     "content": "<p>في كثير من الأحيان، نحتاج كمطورين إلى عرض البيانات بطريقة تكون طبيعية وسهلة الفهم للمستخدمين. على سبيل المثال، بدلاً من عرض حجم ملف كرقم كبير مثل '15042934' بايت، من الأفضل عرضه كنص مثل '14.3 ميجابايت'. هنا يأتي دور مكتبة <strong>Humanize</strong> في بايثون.</p><p>مكتبة Humanize هي أداة بسيطة وفعالة لتحويل البيانات التقنية (مثل الأرقام، التواريخ، والأحجام) إلى صيغة يمكن للبشر قراءتها بسهولة. في هذا المقال، سنستعرض أهم وظائف هذه المكتبة وكيفية استخدامها.</p><h2>1. التثبيت (Installation)</h2><p>قبل البدء، يجب عليك تثبيت المكتبة. يمكنك فعل ذلك بسهولة باستخدام 'pip':</p><pre><code class='language-bash'>pip install humanize</code></pre><h2>2. تحويل الأرقام الكبيرة (intcomma)</h2><p>تساعد دالة <code>intcomma</code> على إضافة فواصل لآلاف في الأرقام الكبيرة، مما يجعلها أسهل في القراءة.</p><pre><code class='language-python'>import humanize\n\nnumber = 1234567\n\n# بدون استخدام المكتبة\nprint(f'الرقم الأصلي: {number}')\n\n# باستخدام humanize.intcomma\nprint(f'الرقم المنسق: {humanize.intcomma(number)}')</code></pre><p><strong>الناتج:</strong></p><pre><code>الرقم الأصلي: 1234567\nالرقم المنسق: 1,234,567</code></pre><h2>3. تحويل الأرقام إلى كلمات (intword)</h2><p>تقوم دالة <code>intword</code> بتحويل الأرقام الكبيرة جدًا إلى صيغة مختصرة باستخدام كلمات مثل 'مليون' أو 'مليار'.</p><pre><code class='language-python'>import humanize\n\nlarge_number = 1560000000\nsmall_number = 85000\n\nprint(f'الرقم الكبير: {humanize.intword(large_number)}')\nprint(f'الرقم الصغير: {humanize.intword(small_number)}')</code></pre><p><strong>الناتج:</strong></p><pre><code>الرقم الكبير: 1.6 مليار\nالرقم الصغير: 85.0 ألف</code></pre><h2>4. عرض التواريخ بشكل نسبي (naturalday و naturaltime)</h2><p>هذه من أقوى ميزات المكتبة. تسمح لك بعرض الفارق الزمني بين تاريخ معين والوقت الحالي بطريقة طبيعية.</p><ul><li><code>naturalday</code>: تعرض اليوم بالنسبة لليوم الحالي (مثل: اليوم، أمس، غداً).</li><li><code>naturaltime</code>: تعرض فارق الوقت بشكل دقيق (مثل: منذ 5 دقائق، بعد ساعتين).</li></ul><pre><code class='language-python'>import humanize\nfrom datetime import datetime, timedelta\n\nnow = datetime.now()\nyesterday = now - timedelta(days=1)\nfive_minutes_ago = now - timedelta(minutes=5)\n\nprint(f'عرض اليوم: {humanize.naturalday(yesterday)}')\nprint(f'عرض الوقت: {humanize.naturaltime(five_minutes_ago)}')</code></pre><p><strong>الناتج (سيكون مختلفًا بناءً على وقت التشغيل):</strong></p><pre><code>عرض اليوم: أمس\nعرض الوقت: منذ 5 دقائق</code></pre><h2>5. تحويل حجم الملفات (naturalsize)</h2><p>هذه الدالة مفيدة جدًا عند التعامل مع أحجام الملفات. تقوم بتحويل عدد البايتات إلى صيغة مفهومة (كيلوبايت، ميجابايت، جيجابايت).</p><pre><code class='language-python'>import humanize\n\nfile_size_bytes = 14784512\n\nprint(f'حجم الملف: {humanize.naturalsize(file_size_bytes)}')\n\n# يمكنك التحكم في التنسيق (مثلاً، استخدام النظام الثنائي)\nprint(f'حجم الملف (ثنائي): {humanize.naturalsize(file_size_bytes, binary=True)}')</code></pre><p><strong>الناتج:</strong></p><pre><code>حجم الملف: 14.8 ميجابايت\nحجم الملف (ثنائي): 14.1 ميبيبايت</code></pre><hr><h3>الخلاصة</h3><p>مكتبة Humanize هي أداة لا غنى عنها لأي مطور بايثون يرغب في تحسين تجربة المستخدم في تطبيقاته. من خلال بضعة أسطر من الكود، يمكنك تحويل البيانات المعقدة إلى نصوص بسيطة وأنيقة تجعل تطبيقك أكثر احترافية وسهولة في الاستخدام.</p><p><strong>هل ترغب في استكشاف مكتبات بايثون أخرى مفيدة؟ <a href='https://www.omarbadrdata.foo/ar/blog/'>تصفح بقية المقالات</a> في المدونة.</strong></p>"
  },
  {
    "id": "mysql-query-mechanics",
    "link": "posts/mysql-query-mechanics/",
    "title": "دليل شامل لبناء استعلامات SQL في MySQL",
    "date": "13 أغسطس 2025",
    "readTime": "10 دقائق",
    "tags": ["SQL", "MySQL", "قواعد البيانات"],
    "image": "assets/images/mysql_queries.jpg",
    "excerpt": "تعرف على جميع بنود استعلامات SQL في MySQL من الميكانيكا الأساسية إلى الفرز والتجميع، مع شرح تفصيلي وأمثلة عملية.",
    "author": {
      "name": "عمر بدر",
      "linkedin": "https://www.linkedin.com/in/omarbadrdata/",
      "avatar": "assets/images/profile.jpg"
    },
     "content": "<h2>1. ميكانيكا الاستعلامات (Query Mechanics)</h2><p>قبل إجراء أي استعلام، يجب إعداد الاتصال بخادم MySQL. تتضمن هذه العملية التحقق من اسم المستخدم وكلمة المرور، والتأكد من أن الخادم يعمل، وأن تطبيق العميل لديه الأذونات اللازمة. بمجرد إنشاء الاتصال، يمكن إرسال الاستعلامات ليتم تنفيذها.</p><p>الخطوات الأساسية لتنفيذ الاستعلام:</p><ul><li><strong>الاتصال بالخادم:</strong> يتم الاتصال بكل خادم MySQL كمعرف فريد عند الاتصال لأول مرة.</li><li><strong>التحقق من الأذونات:</strong> يجب أن يكون لدى المستخدم أذونات لتنفيذ الاستعلام والوصول إلى البيانات المطلوبة.</li><li><strong>التحقق من بناء الجملة (Syntax):</strong> يتأكد محلل الاستعلام من صحة بناء الجملة قبل التنفيذ.</li><li><strong>محلل الاستعلام (Query Optimizer):</strong> مسؤول عن تحديد الطريقة الأكثر كفاءة لتنفيذ الاستعلام، وتحديد ترتيب جداول الانضمام، واختيار المؤشرات المناسبة، وإنشاء خطة التنفيذ.</li><li><strong>مجموع النتائج (Result Set):</strong> بمجرد تنفيذ الاستعلام، يتم إرجاع النتائج في شكل جدول يحتوي على الأعمدة والصفوف المطلوبة.</li></ul><h2>2. بند SELECT</h2><p>هو البند الأهم في استعلامات SQL، حيث يحدد الأعمدة التي سيتم عرضها في النتائج.</p><ul><li>اختيار جميع الأعمدة باستخدام <code>*</code>.</li><li>اختيار أعمدة محددة بذكر أسمائها مفصولة بفواصل.</li><li>إضافة القيم الحرفية أو الأرقام أو السلاسل.</li><li>استخدام التعبيرات الرياضية أو الوظائف المدمجة.</li><li>إضافة وظائف معرفة من قبل المستخدم.</li><li>تعيين أسماء مستعارة للأعمدة باستخدام <code>AS</code> لزيادة وضوح النتائج.</li><li>إزالة التكرارات باستخدام <code>DISTINCT</code>.</li></ul><h2>3. بند FROM</h2><p>يحدد الجداول التي يتم جلب البيانات منها.</p><ul><li><strong>الجداول الدائمة:</strong> يتم إنشاؤها باستخدام <code>CREATE TABLE</code> وتظل في قاعدة البيانات.</li><li><strong>الجداول المشتقة:</strong> ناتجة عن استعلام فرعي وتخزن في الذاكرة.</li><li><strong>الجداول المؤقتة:</strong> تخزن البيانات مؤقتًا وتختفي بنهاية الجلسة.</li><li><strong>العروض (Views):</strong> استعلام مخزن يعمل كجدول افتراضي دون بيانات فعلية.</li><li><strong>ربط الجداول (JOIN):</strong> دمج الصفوف من جداول متعددة بناءً على عمود مشترك.</li><li><strong>أسماء الجداول المستعارة:</strong> لتبسيط الاستعلامات خاصة عند ربط جداول متعددة.</li></ul><h2>4. بند WHERE</h2><p>يستخدم لتصفية الصفوف بناءً على شروط محددة.</p><ul><li>التصفية المباشرة على الصفوف.</li><li>استخدام العوامل المنطقية <code>AND</code> و<code>OR</code> للجمع بين الشروط.</li><li>إنشاء شروط معقدة باستخدام الأقواس.</li></ul><h2>5. التجميع والتصنيف (GROUP BY وHAVING)</h2><p><code>GROUP BY</code> يجمع الصفوف التي لها قيم متطابقة في عمود أو أكثر، وغالبًا ما يستخدم مع دوال التجميع مثل <code>COUNT()</code> و<code>SUM()</code> و<code>AVG()</code>.</p><ul><li><strong>تجميع البيانات:</strong> لتحليل البيانات ضمن مجموعات بدلاً من الصفوف الفردية.</li><li><strong>HAVING:</strong> لتصفية المجموعات الناتجة بعد التجميع، على عكس WHERE الذي يعمل على الصفوف الفردية.</li></ul><h2>6. بند ORDER BY</h2><p>يستخدم لفرز النتائج تصاعديًا (<code>ASC</code>) أو تنازليًا (<code>DESC</code>).</p><ul><li>تحديد ترتيب الفرز حسب عمود واحد أو أكثر.</li><li>إمكانية الفرز بأكثر من عمود.</li><li>الفرز باستخدام تعبيرات أو وظائف.</li></ul><hr><h3>الخلاصة</h3><p>إتقان هذه البنود يمنحك القدرة على كتابة استعلامات SQL أكثر وضوحًا وكفاءة، مما يسهل تحليل البيانات واستخراج النتائج بدقة.</p>"
  },
  {
    "id": "professional-readme-prompt",
    "link": "posts/professional-readme-prompt/",
    "title": "من مجرد كود إلى قصة متكاملة: دليلك لكتابة README احترافي",
    "date": "13 أغسطس 2025",
    "readTime": "7 دقائق",
    "tags": ["GitHub", "كتابة تقنية", "علامة تجارية شخصية"],
    "image": "assets/images/professional_readme_prompt.png",
    "excerpt": "ملف README ليس مجرد توثيق، بل هو الواجهة الأولى لمشروعك. تعلم كيف تستخدم هذا البرومبت الاستراتيجي لتحويل الكود الصامت إلى قصة نجاح مقنعة.",
    "author": {
      "name": "عمر بدر",
      "linkedin": "https://www.linkedin.com/in/omarbadrdata/",
      "avatar": "assets/images/profile.jpg"
    },
    "content": "<h2>مقدمة: عندما لا يكون الكود كافيًا</h2><p>كل مطور يعرف هذا الشعور: بعد أسابيع من العمل الشاق، بناء خوارزميات معقدة، وحل مشاكل صعبة، أخيرًا، المشروع جاهز. الكود يعمل بكفاءة، والنتائج رائعة. لكن عندما ترفعه إلى GitHub، تضع عنوانًا بسيطًا وبضع أسطر في ملف README وتعتبر المهمة منتهية.</p><p>هنا تكمن المشكلة. <strong>المشروع الرائع مع ملف README ضعيف هو كتحفة فنية مخبأة في قبو مظلم؛ قيمتها موجودة، لكن لا أحد يستطيع رؤيتها.</strong> ملف README ليس مجرد توثيق، بل هو الواجهة، المسوّق، والمرشد السياحي لمشروعك. إنه الجسر الذي يصل بين عملك التقني المعقد وبين العالم الخارجي.</p><h2>لماذا يفشل معظم المطورين في كتابة README جيد؟</h2><p>السبب بسيط: نحن نركز على 'كيف' يعمل الكود، وننسى أن نشرح 'لماذا' هو مهم. ملف README الجيد لا يخاطب المطورين الآخرين فقط، بل يخاطب أيضًا:</p><ul><li><strong>مسؤولي التوظيف (Recruiters):</strong> الذين يريدون أن يفهموا القيمة التجارية للمشروع في 30 ثانية.</li><li><strong>المتعاونين المحتملين (Collaborators):</strong> الذين يحتاجون إلى معرفة هيكل المشروع وكيف يمكنهم المساهمة.</li><li><strong>'أنت' المستقبلي (Future You):</strong> الذي سيعود للمشروع بعد 6 أشهر ويحتاج إلى تذكر سبب كل قرار اتخذته.</li></ul><h2>الحل: برومبت استراتيجي لبناء قصة مشروعك</h2><p>لمساعدتك في بناء هذا الجسر، قمت بإعداد برومبت (Prompt) مصمم ليكون بمثابة 'خارطة طريق' لكتابة ملف README احترافي. هذا البرومبت لا يطلب منك مجرد ملء فراغات، بل يجبرك على التفكير في مشروعك من منظور استراتيجي.</p><h3>البرومبت النهائي</h3><blockquote><p>أنت كاتب تقني خبير ومتخصص في توثيق المشاريع البرمجية. مهمتك هي كتابة ملف README لمشروع برمجي بطريقة واضحة، احترافية، وشاملة. يجب أن يكون الملف مصممًا ليكون مفهومًا من قبل جمهور متنوع، بما في ذلك المطورين، مديري التوظيف، وأصحاب المصلحة غير التقنيين.</p><p><strong>عناصر الـ README المطلوبة:</strong></p><p><strong>الأساسيات (Fundamentals):</strong></p><ol><li><strong>العنوان (Title):</strong> عنوان جذاب ومعبر عن المشروع.</li><li><strong>جدول المحتويات (Table of Contents):</strong> لتسهيل التنقل.</li><li><strong>وصف المشروع (Project Description):</strong> نظرة عامة موجزة عن المشروع وأهدافه الرئيسية.</li><li><strong>المشكلة التي يحلها (Problem It Solves):</strong> اشرح بوضوح ما هي المشكلة أو الفجوة التي يعالجها هذا المشروع.</li></ol><p><strong>التفاصيل التقنية (Technical Details):</strong></p><ol><li><strong>التقنيات المستخدمة ولماذا (Tech Stack & Rationale):</strong> قائمة بالتقنيات والأدوات والمكتبات المستخدمة، مع شرح موجز لسبب اختيار كل منها.</li><li><strong>وصف العملية (The Process):</strong> اشرح الخطوات الرئيسية التي مر بها المشروع، من جمع البيانات (إن وجد) إلى بناء النموذج أو التطبيق. صف القرارات الهندسية المهمة التي اتخذتها.</li><li><strong>كيفية تشغيل المشروع (Getting Started):</strong> دليل واضح خطوة بخطوة حول كيفية تثبيت وتشغيل المشروع محليًا.</li></ol><p><strong>الطبقة السردية (Storytelling Layer):</strong></p><ol><li><strong>الدافع وراء المشروع (Motivation):</strong> ما الذي ألهمك للعمل على هذه المشكلة تحديدًا؟</li><li><strong>التحديات والحلول (Challenges & Solutions):</strong> اذكر 1-2 من التحديات التقنية الكبرى التي واجهتها وكيف تغلبت عليها. هذا يظهر قدرتك على حل المشكلات.</li><li><strong>النتائج والتأثير (Outcomes & Impact):</strong> كيف يبدو المنتج النهائي؟ ما هي النتائج الرئيسية للتحليل أو قدرات التطبيق؟</li><li><strong>القيود والتحسينات المستقبلية (Limitations & Future Work):</strong> اذكر أي قيود معروفة في المشروع والأفكار التي لديك لتطويره مستقبلًا. هذا يظهر النزاهة والتفكير الاستراتيجي.</li><li><strong>الاستخدام المقصود (Intended Use):</strong> من هو الجمهور المستهدف لهذا المشروع؟ وكيف يمكنهم الاستفادة منه؟</li><li><strong>الحقوق والشكر (Credits & License):</strong> اذكر أي مصادر بيانات أو أكواد استعنت بها، وحدد نوع الترخيص.</li></ol></blockquote><h3>كيف تستخدم البرومبت بفعالية؟</h3><ol><li><strong>اجمع معلوماتك أولاً:</strong> قبل استخدام البرومبت، جهّز نقاطًا مختصرة عن كل عنصر من العناصر المطلوبة لمشروعك.</li><li><strong>ابدأ الحوار مع الذكاء الاصطناعي:</strong> انسخ البرومبت، ثم قدم معلومات مشروعك التي جهزتها.</li><li><strong>اعتبره مسودة أولى:</strong> الناتج الذي ستحصل عليه من أداة الذكاء الاصطناعي هو مسودة ممتازة، وليس النسخة النهائية. قم بمراجعته، أضف لمستك الشخصية، وصحح أي تفاصيل ليعكس صوتك وخبرتك الحقيقية.</li></ol><hr><h3>الخلاصة: استثمر في واجهة مشروعك</h3><p>ملف README الاحترافي ليس رفاهية، بل هو استثمار مباشر في علامتك التجارية الشخصية كمطور. إنه يحول مستودعك من مجرد أرشيف للأكواد إلى معرض أعمال حي يروي قصة مهاراتك وقدرتك على تحقيق الإنجازات.</p>"
  },
  {
    "id": "data-analysis-guide",
    "link": "posts/data-analysis-guide/",
    "title": "إزاي تبدأ أي مشروع تحليل بيانات صح؟",
    "date": "20 أغسطس 2025",
    "readTime": "10 دقائق",
    "tags": ["تحليل بيانات", "إدارة مشاريع", "تحليل استكشافي", "Data Storytelling"],
    "image": "assets/images/data_analysis_guide.png",
    "excerpt": "دليل عملي خطوة بخطوة لتبدأ مشروع تحليل بيانات بطريقة منظمة واحترافية، من فهم الهدف إلى تحويل البيانات إلى قرارات مؤثرة.",
    "author": {
      "name": "عمر بدر",
      "linkedin": "https://www.linkedin.com/in/omarbadrdata/",
      "avatar": "assets/images/profile.jpg"
    },
    "content": "<h2>مقدمة</h2><p>في عالم بقى كله بيتكلم عن البيانات، أي شركة أو مؤسسة صغيرة أو كبيرة بتدرك إن \"البيانات هي البترول الجديد\". لكن الحقيقة إن البيانات لوحدها ملهاش قيمة من غير تحليل صح يقدر يحولها من أرقام وجداول لـ معلومات، ثم Insights، وأخيرًا قرارات.</p><p>اللي بيحدد نجاح أي مشروع تحليل بيانات مش إنك تعرف بايثون أو SQL أو Power BI كويس وبس، لكن كمان إزاي تبدأ صح. البداية الصح بتوفّر عليك وقت ومجهود وتخليك تركز على اللي فعلاً هيضيف قيمة للبزنس.</p><p>في المقال ده، هشارك معاك منهجية عملية بخطوات واضحة تساعدك تبدأ أي مشروع تحليل بيانات بشكل منظم واحترافي.</p><h2>1. افهم الهدف قبل البيانات</h2><p>أكتر خطأ شائع بيعمله محللي البيانات المبتدئين (وأحيانًا حتى المحترفين) إنهم يبدأوا يشتغلوا على البيانات مباشرة قبل ما يفهموا المشكلة أو السؤال الأساسي.</p><p><strong>أسئلة لازم تجاوب عليها:</strong></p><ul><li>إيه الهدف من التحليل؟</li><li>إيه القرار اللي صاحب البزنس أو الإدارة عاوزين ياخدوه بناءً على النتايج؟</li><li>إيه الـKPIs (مؤشرات الأداء) اللي يهمهم يعرفوها؟</li></ul><p><strong>مثال عملي:</strong></p><p>لو عندك شركة تجارة إلكترونية، السؤال ممكن يكون:</p><ul><li>\"ليه معدل تحويل الزوار لعملاء قليل؟\"</li><li>\"مين العملاء اللي عندهم احتمالية عالية يسيبوا الخدمة؟\"</li></ul><p>الفهم ده هو اللي هيحدد نوع البيانات اللي محتاج تجمعها، وطريقة التحليل اللي هتستخدمها.</p><h2>2. جمع وتجهيز البيانات (Data Collection & Preparation)</h2><p>المرحلة دي بتاخد 60-70% من وقت أي مشروع تحليل بيانات.</p><p>السبب بسيط: أغلب البيانات الواقعية غير كاملة، مليانة أخطاء، ومش متنسقة.</p><p><strong>خطوات عملية:</strong></p><ul><li><strong>جمع البيانات:</strong> من قواعد بيانات داخلية، ملفات Excel، APIs، أو حتى Web Scraping.</li><li><strong>تنظيف البيانات:</strong><ul><li>معالجة القيم المفقودة (Missing Values).</li><li>التعامل مع القيم الشاذة (Outliers).</li><li>توحيد التنسيقات (تواريخ، عملات، وحدات قياس).</li></ul></li><li><strong>دمج البيانات (Data Integration):</strong> لو عندك أكتر من مصدر بيانات، لازم تدمجهم بشكل ذكي عشان تطلع صورة كاملة.</li></ul><p><strong>مثال:</strong></p><p>لو بتحلل سلوك العملاء، ممكن تحتاج تجمع بيانات المبيعات + بيانات زيارات الموقع + بيانات خدمة العملاء.</p><h2>3. الاستكشاف والتحليل الوصفي (Exploratory Data Analysis - EDA)</h2><p>بعد ما البيانات بقت نظيفة، تبدأ مرحلة الفهم العميق.</p><p><strong>الهدف:</strong></p><ul><li>التعرف على الأنماط (Trends).</li><li>اكتشاف العلاقات بين المتغيرات.</li><li>ملاحظة أي شذوذ في البيانات.</li></ul><p><strong>أدوات ممكن تستخدمها:</strong></p><ul><li>Python (Pandas, Matplotlib, Seaborn, Plotly).</li><li>Power BI أو Tableau لو عايز Visual سريع.</li></ul><p><strong>مثال عملي:</strong></p><p>لو بتحلل بيانات متجر إلكتروني، ممكن تكتشف إن:</p><ul><li>أكتر الفئات الشرائية نشاطًا هي \"الشباب 18-24\".</li><li>معدل الشراء بيزيد في عطلة نهاية الأسبوع.</li><li>متوسط قيمة الطلب (AOV) أعلى عند العملاء اللي جُم من إعلانات فيسبوك مقارنة بجوجل.</li></ul><h2>4. التحليل المتقدم (Advanced Analytics)</h2><p>بعد ما استكشفت البيانات وفهمت أساسياتها، هنا ممكن تدخل في تحليل أعمق.</p><p><strong>أنواع التحليل:</strong></p><ul><li>تحليل إحصائي: لاختبار الفرضيات.</li><li>تحليل تنبؤي (Predictive Modeling): باستخدام Machine Learning (زي توقع مبيعات المستقبل).</li><li>تحليل توصياتي (Recommendation Systems): عشان تقترح منتجات أو خدمات للعملاء.</li></ul><p><strong>مثال عملي:</strong></p><p>لو بتشتغل في SaaS Company، ممكن تبني نموذج Churn Prediction يتوقع مين العملاء اللي ممكن يلغوا اشتراكهم الشهر الجاي، وتساعد فريق التسويق يعمل لهم حملات احتفاظ مخصصة.</p><h2>5. تحويل النتايج لقصص (Data Storytelling)</h2><p>واحدة من أهم المهارات اللي بتميز المحلل الناجح عن مجرد \"مُبرمج\" هي قدرته على حكي القصة وراء البيانات.</p><p><strong>نصائح:</strong></p><ul><li>استخدم Visualizations واضحة (خط، أعمدة، Pie – بس بحكمة).</li><li>قلل التفاصيل التقنية لما تشرح لغير المتخصصين.</li><li>اربط دايمًا النتايج بالـBusiness Goal الأساسي.</li></ul><p><strong>مثال:</strong></p><p>بدل ما تقول:</p><p>\"تحليل الانحدار اللوجستي أظهر إن احتمال الـChurn يزيد بنسبة 35% لما يقل معدل التفاعل الشهري تحت 3 مرات.\"</p><p>قول:</p><p>\"العملاء اللي بيتفاعلو أقل من 3 مرات في الشهر عندهم احتمالية أعلى بنسبة 35% يلغوا اشتراكهم. لو ركزنا نرفع معدل التفاعل لمرتين إضافيتين، ممكن نقلل معدل فقد العملاء بشكل كبير.\"</p><h2>6. بناء لوحة متابعة (Dashboard)</h2><p>التحليل مش بينتهي بملف Excel أو تقرير PDF. الأفضل تبني Dashboard تفاعلية تسهل على متخذي القرار متابعة المؤشرات في أي وقت.</p><p><strong>أدوات شائعة:</strong></p><ul><li>Power BI.</li><li>Tableau.</li><li>Google Data Studio (لو عاوز مجاني).</li></ul><p>الـDashboard بتخلي الإدارة تتابع KPIs زي:</p><ul><li>المبيعات اليومية.</li><li>معدل اكتساب العملاء الجدد.</li><li>نسبة الاحتفاظ بالعملاء.</li></ul><h2>7. التوصيات واتخاذ القرار</h2><p>التحليل ملوش قيمة لو وقف عند \"الوصف\". لازم ينتهي عند:</p><ul><li>توصيات واضحة (Recommendations).</li><li>إجراءات عملية (Actions).</li><li>قياس النتائج بعد التنفيذ.</li></ul><p><strong>مثال عملي:</strong></p><p>لو اكتشفت إن 20% من العملاء بيحققوا 80% من الإيرادات (قاعدة باريتو)، ممكن توصية التحليل تكون:</p><p>\"خصصوا حملات ولاء (Loyalty Programs) للشريحة دي.\"</p><h2>8. استمرارية التحليل (Iteration)</h2><p>تحليل البيانات مش عملية لمرة واحدة، لكنه دورة مستمرة.</p><p><strong>كل مشروع يفتح باب لأسئلة جديدة.</strong></p><p>كل ما البيانات تكبر وتتنوع، بتحتاج مراجعة وتحديث التحليلات.</p><p>المحلل الشاطر هو اللي بيبني نظام متكامل لتحليل البيانات، مش مجرد مشروع لمرة واحدة.</p><h2>أخطاء شائعة لازم تتجنبها</h2><ul><li>القفز على الأدوات قبل فهم المشكلة.</li><li>الإفراط في الـVisualizations (الهدف مش تزويق شكل، الهدف توصيل رسالة).</li><li>تجاهل السياق البزنس والتركيز على الجانب التقني فقط.</li><li>مشاركة النتايج بلغة تقنية مع مدير أو صاحب بزنس مش متخصص.</li></ul><hr><h2>الخلاصة</h2><p>لو عايز تبدأ أي مشروع تحليل بيانات صح:</p><ol><li>افهم الهدف.</li><li>جهّز البيانات كويس.</li><li>اعمل تحليل استكشافي.</li><li>عمّق التحليل لو محتاج.</li><li>احكي القصة من خلال البيانات.</li><li>ابني Dashboard للتتبع.</li><li>حوّل النتايج لقرارات.</li><li>كرر العملية باستمرار.</li></ol><p>التحليل الصح مش بيقاس بعدد الأكواد اللي كتبتها ولا عدد الرسومات اللي طلعتها، لكن بمدى القيمة اللي ضفتها للبزنس.</p>"
  },
  {
  "id": "sql-subqueries-guide",
  "link": "posts/sql-subqueries-guide/",
  "title": "الاستعلامات الفرعية (Subquery) في SQL: دليل شامل ومفصل",
  "date": "28 أغسطس 2025",
  "readTime": "15 دقيقة",
  "tags": ["SQL", "قواعد البيانات", "شروحات تقنية"],
  "image": "assets/images/sql_subquery_cover.jpg",
  "excerpt": "دليل متكامل يفصل كل ما تحتاج لمعرفته عن الاستعلامات الفرعية في SQL، من الأنواع المختلفة وأماكن الاستخدام إلى أفضل الممارسات لتحسين الأداء.",
  "author": {
    "name": "عمر بدر",
    "linkedin": "https://www.linkedin.com/in/omarbadrdata/",
    "avatar": "assets/images/omar.jpg"
  },
  "content": "<h2>مقدمة تعريفية</h2><h3>تعريف الـ Subquery ولماذا نستخدمه</h3><p>الاستعلام الفرعي (Subquery) هو استعلام SQL مدمج داخل استعلام آخر. يُعرف أيضاً بالاستعلام الداخلي (Inner Query) أو الاستعلام المتداخل (Nested Query)، بينما يُطلق على الاستعلام الذي يحتويه اسم الاستعلام الخارجي (Outer Query).</p><p>يمكن استخدام الاستعلامات الفرعية في بيانات SELECT، INSERT، UPDATE، وDELETE، وهي تُنفذ قبل الاستعلام الخارجي وتمرر نتائجها لإكمال العملية.</p><h3>أهميته في كتابة استعلامات متقدمة</h3><p>الاستعلامات الفرعية توفر عدة فوائد مهمة في كتابة استعلامات SQL متقدمة:</p><ul><li><strong>تجنب تكرار الكود:</strong> تساعد في تجنب تكرار المنطق المعقد في أماكن متعددة.</li><li><strong>تحسين قابلية القراءة:</strong> تقسم الاستعلامات المعقدة إلى كتل قابلة للفهم والإدارة.</li><li><strong>المرونة في التصفية:</strong> تسمح بتصفية البيانات ديناميكياً بناءً على نتائج استعلامات أخرى.</li><li><strong>العمليات المعقدة:</strong> تُمكن من إجراء حسابات أو تحليلات معقدة عبر تقسيم العمل إلى خطوات.</li></ul><hr><h2>أنواع Subquery مع الشرح المفصل والأمثلة</h2><h3>Single-row subquery</h3><p>هذا النوع يعيد صفاً واحداً فقط كنتيجة، ويُستخدم عادة مع عوامل المقارنة مثل <code>=</code>, <code>&gt;</code>, <code>&lt;</code>.</p><pre><code class='language-sql'>-- البحث عن الموظف الذي يحصل على أعلى راتب\nSELECT * FROM Employees\nWHERE Salary = (SELECT MAX(Salary) FROM Employees);\n\n-- البحث عن الموظفين الذين رواتبهم أكبر من متوسط الرواتب\nSELECT EmployeeName, Salary FROM Employees \nWHERE Salary > (SELECT AVG(Salary) FROM Employees);</code></pre><h3>Multiple-row subquery</h3><p>يعيد هذا النوع عدة صفوف كنتيجة، ويتطلب استخدام عوامل يمكنها التعامل مع قيم متعددة مثل <code>IN</code>, <code>ANY</code>, <code>ALL</code>.</p><pre><code class='language-sql'>-- باستخدام IN: البحث عن الموظفين في أقسام محددة\nSELECT * FROM Employees\nWHERE DepartmentID IN (SELECT DepartmentID FROM Departments \n                      WHERE Location = 'New York');\n\n-- باستخدام ANY: البحث عن المنتجات الأغلى من أي منتج في فئة معينة\nSELECT ProductName, Price FROM Products\nWHERE Price > ANY (SELECT Price FROM Products WHERE Category = 'Electronics');\n\n-- باستخدام ALL: البحث عن المنتجات الأغلى من جميع المنتجات في فئة معينة\nSELECT ProductName, Price FROM Products\nWHERE Price > ALL (SELECT Price FROM Products WHERE Category = 'Books');</code></pre><h3>Multiple-column subquery</h3><p>هذا النوع يسترجع أكثر من عمود واحد، مما يُمكن من مقارنة قيم متعددة في نفس الوقت.</p><pre><code class='language-sql'>-- البحث عن الطلبات التي تطابق أقل سعر لكل منتج\nSELECT OrderID, ProductID, UnitPrice FROM OrderDetails\nWHERE (ProductID, UnitPrice) IN \n    (SELECT ProductID, MIN(UnitPrice) FROM OrderDetails \n     GROUP BY ProductID);\n\n-- البحث عن الموظفين الذين يعملون في نفس القسم ولديهم نفس المسمى الوظيفي\nSELECT * FROM Employees E1\nWHERE (DepartmentID, JobTitle) IN \n    (SELECT DepartmentID, JobTitle FROM Employees E2 \n     WHERE E1.EmployeeID != E2.EmployeeID);</code></pre><h3>Correlated subquery مقابل Non-correlated subquery</h3><h4>Non-correlated subquery</h4><p>الاستعلام الفرعي غير المترابط يُنفذ بشكل مستقل عن الاستعلام الخارجي ولا يعتمد على قيم من الاستعلام الخارجي.</p><pre><code class='language-sql'>-- استعلام غير مترابط - يُنفذ مرة واحدة فقط\nSELECT EmployeeID, EmployeeName, Salary\nFROM Employees\nWHERE Salary > (SELECT AVG(Salary) FROM Employees);</code></pre><h4>Correlated subquery</h4><p>الاستعلام الفرعي المترابط يعتمد على قيم من الاستعلام الخارجي ويُنفذ مرة واحدة لكل صف في الاستعلام الخارجي.</p><pre><code class='language-sql'>-- استعلام مترابط - يُنفذ لكل موظف على حدة\nSELECT e.EmployeeName, e.Salary, e.DepartmentID\nFROM Employees e\nWHERE e.Salary > (SELECT AVG(Salary) \n                  FROM Employees \n                  WHERE DepartmentID = e.DepartmentID);\n\n-- مثال آخر: البحث عن العملاء الذين لديهم أكثر من طلب واحد\nSELECT CustomerName FROM Customers C\nWHERE EXISTS (SELECT 1 FROM Orders O \n              WHERE O.CustomerID = C.CustomerID \n              HAVING COUNT(*) > 1);</code></pre><h3>Nested subqueries (Subquery داخل Subquery)</h3><p>يمكن أن تحتوي الاستعلامات الفرعية على استعلامات فرعية أخرى، مما يُمكن من إنشاء منطق معقد.</p><pre><code class='language-sql'>-- البحث عن المنتجات التي كميتها أكبر من منتج معين\nSELECT ProductName, Quantity FROM Products \nWHERE ProductID IN \n    (SELECT ProductID FROM OrderDetails \n     WHERE Quantity > \n        (SELECT Quantity FROM OrderDetails \n         WHERE OrderDetailID = 10));\n\n-- مثال أكثر تعقيداً: البحث عن الموظفين في الأقسام التي متوسط رواتبها أعلى من متوسط عام\nSELECT * FROM Employees\nWHERE DepartmentID IN \n    (SELECT DepartmentID FROM Employees\n     GROUP BY DepartmentID\n     HAVING AVG(Salary) > \n        (SELECT AVG(Salary) FROM Employees));</code></pre><hr><h2>أماكن استخدام Subquery</h2><h3>في جملة SELECT</h3><p>يُستخدم الاستعلام الفرعي في جملة SELECT لإنشاء أعمدة محسوبة ديناميكياً.</p><pre><code class='language-sql'>-- إضافة عمود يحتوي على عدد الطلبات لكل عميل\nSELECT CustomerID, CustomerName,\n       (SELECT COUNT(*) FROM Orders O \n        WHERE O.CustomerID = C.CustomerID) AS TotalOrders\nFROM Customers C;\n\n-- إضافة عمود يحتوي على أعلى سعر في نفس الفئة\nSELECT ProductName, Price, Category,\n       (SELECT MAX(Price) FROM Products P2 \n        WHERE P2.Category = P1.Category) AS MaxPriceInCategory\nFROM Products P1;</code></pre><h3>في جملة FROM كجدول وهمي</h3><p>يمكن استخدام الاستعلام الفرعي في جملة FROM لإنشاء جدول مؤقت.</p><pre><code class='language-sql'>-- حساب متوسط المشتريات لكل عميل\nSELECT CustomerID, CustomerName, AvgPurchase\nFROM (\n    SELECT C.CustomerID, C.CustomerName,\n           ROUND(SUM(O.TotalAmount) / COUNT(O.OrderID), 2) AS AvgPurchase\n    FROM Customers C\n    INNER JOIN Orders O ON C.CustomerID = O.CustomerID\n    GROUP BY C.CustomerID, C.CustomerName\n) AS CustomerStats\nWHERE AvgPurchase > 500;\n\n-- إنشاء تقرير مبيعات شهري\nSELECT Month, TotalSales, AvgOrderValue\nFROM (\n    SELECT MONTH(OrderDate) AS Month,\n           SUM(TotalAmount) AS TotalSales,\n           AVG(TotalAmount) AS AvgOrderValue\n    FROM Orders\n    WHERE YEAR(OrderDate) = 2024\n    GROUP BY MONTH(OrderDate)\n) AS MonthlySales\nORDER BY Month;</code></pre><h3>في جملة WHERE للفلاتر</h3><p>هذا أكثر الاستخدامات شيوعاً للاستعلامات الفرعية.</p><pre><code class='language-sql'>-- البحث عن العملاء الذين لم يقوموا بأي طلبات\nSELECT CustomerName FROM Customers\nWHERE CustomerID NOT IN (SELECT DISTINCT CustomerID FROM Orders \n                        WHERE CustomerID IS NOT NULL);\n\n-- البحث عن المنتجات التي لم يتم طلبها مطلقاً\nSELECT ProductName FROM Products\nWHERE ProductID NOT EXISTS (SELECT 1 FROM OrderDetails \n                           WHERE ProductID = Products.ProductID);\n\n-- البحث عن الطلبات الأكبر من متوسط قيمة الطلبات في نفس الشهر\nSELECT OrderID, OrderDate, TotalAmount\nFROM Orders O1\nWHERE TotalAmount > (SELECT AVG(TotalAmount) FROM Orders O2\n                    WHERE MONTH(O1.OrderDate) = MONTH(O2.OrderDate)\n                    AND YEAR(O1.OrderDate) = YEAR(O2.OrderDate));</code></pre><h3>في جملة HAVING مع Group By</h3><p>يُستخدم مع التجميع لتصفية المجموعات بناءً على شروط معقدة.</p><pre><code class='language-sql'>-- البحث عن الأقسام التي متوسط رواتبها أعلى من المتوسط العام\nSELECT DepartmentID, AVG(Salary) AS AvgSalary\nFROM Employees\nGROUP BY DepartmentID\nHAVING AVG(Salary) > (SELECT AVG(Salary) FROM Employees);\n\n-- البحث عن العملاء الذين إجمالي مشترياتهم أعلى من متوسط المشتريات\nSELECT CustomerID, SUM(TotalAmount) AS TotalPurchases\nFROM Orders\nGROUP BY CustomerID\nHAVING SUM(TotalAmount) > (SELECT AVG(CustomerTotal) \n                          FROM (SELECT SUM(TotalAmount) AS CustomerTotal \n                               FROM Orders GROUP BY CustomerID) AS AvgCalc);</code></pre><h3>في جملة UPDATE / DELETE</h3><p>الاستعلامات الفرعية مفيدة جداً في عمليات التحديث والحذف المشروطة.</p><h4>أمثلة عملية للـ UPDATE:</h4><pre><code class='language-sql'>-- تحديث رواتب الموظفين بناءً على متوسط القسم\nUPDATE Employees \nSET Salary = Salary * 1.1\nWHERE DepartmentID IN (SELECT DepartmentID FROM Departments \n                      WHERE Budget > 100000);\n\n-- تحديث حالة الطلبات بناءً على التاريخ\nUPDATE Orders \nSET Status = 'Expired'\nWHERE OrderDate < (SELECT DATE_SUB(CURDATE(), INTERVAL 30 DAY))\nAND Status = 'Pending';\n\n-- تحديث أسعار المنتجات بناءً على الفئة\nUPDATE Products \nSET Price = Price * 0.9\nWHERE CategoryID IN (SELECT CategoryID FROM Categories \n                    WHERE CategoryName = 'Clearance');</code></pre><h4>أمثلة عملية للـ DELETE:</h4><pre><code class='language-sql'>-- حذف الطلبات القديمة التي تم تسليمها\nDELETE FROM Orders \nWHERE OrderDate < (SELECT DATE_SUB(CURDATE(), INTERVAL 365 DAY))\nAND Status = 'Delivered';\n\n-- حذف العملاء الذين لم يقوموا بأي طلبات\nDELETE FROM Customers \nWHERE CustomerID NOT IN (SELECT DISTINCT CustomerID FROM Orders \n                        WHERE CustomerID IS NOT NULL);\n\n-- حذف المنتجات غير المبيعة\nDELETE FROM Products \nWHERE ProductID NOT EXISTS (SELECT 1 FROM OrderDetails \n                           WHERE ProductID = Products.ProductID);</code></pre><hr><h2>مقارنة بين Subquery و JOIN</h2><h3>متى نستخدم Subquery ومتى نستخدم JOIN</h3><h4>استخدام JOIN عندما:</h4><ul><li>نحتاج لدمج بيانات من جداول متعددة في النتيجة النهائية.</li><li> نريد أداءً أفضل مع مجموعات البيانات الكبيرة.</li><li> العلاقة بين الجداول واضحة ومحددة.</li></ul><h4>استخدام Subquery عندما:</h4><ul><li>نحتاج لتصفية البيانات بناءً على معايير معقدة.</li><li> نريد كتابة كود أكثر قابلية للقراءة للاستعلامات المعقدة.</li><li> نحتاج لحسابات متدرجة أو معايير ديناميكية.</li></ul><h3>أمثلة عملية توضح الفروق</h3><pre><code class='language-sql'>-- مثال 1: نفس النتيجة بطريقتين\n\n-- باستخدام Subquery\nSELECT CustomerName FROM Customers\nWHERE CustomerID IN (SELECT CustomerID FROM Orders \n                    WHERE OrderDate >= '2024-01-01');\n\n-- باستخدام JOIN (عادة أسرع)\nSELECT DISTINCT C.CustomerName \nFROM Customers C\nINNER JOIN Orders O ON C.CustomerID = O.CustomerID\nWHERE O.OrderDate >= '2024-01-01';</code></pre><pre><code class='language-sql'>-- مثال 2: حالة يفضل فيها Subquery\n\n-- البحث عن المنتجات الأغلى من متوسط سعر فئتها (أوضح وأسهل فهماً)\nSELECT ProductName, Price, Category\nFROM Products P1\nWHERE Price > (SELECT AVG(Price) FROM Products P2 \n              WHERE P2.Category = P1.Category);\n\n-- بـ JOIN (أكثر تعقيداً وأقل وضوحاً)\nSELECT P1.ProductName, P1.Price, P1.Category\nFROM Products P1\nINNER JOIN (SELECT Category, AVG(Price) AS AvgPrice \n           FROM Products GROUP BY Category) P2\nON P1.Category = P2.Category\nWHERE P1.Price > P2.AvgPrice;</code></pre><pre><code class='language-sql'>-- مثال 3: حالة يفضل فيها JOIN\n\n-- إظهار تفاصيل الطلبات مع معلومات العميل (الطريقة المثلى)\nSELECT O.OrderID, O.OrderDate, C.CustomerName, C.City\nFROM Orders O\nINNER JOIN Customers C ON O.CustomerID = C.CustomerID;\n\n-- بـ Subquery (غير عملي هنا)\nSELECT OrderID, OrderDate,\n       (SELECT CustomerName FROM Customers \n        WHERE CustomerID = Orders.CustomerID) AS CustomerName,\n       (SELECT City FROM Customers \n        WHERE CustomerID = Orders.CustomerID) AS City\nFROM Orders;</code></pre><hr><h2>أفضل الممارسات (Best Practices)</h2><h3>تحسين الأداء</h3><h4>استخدام EXISTS بدلاً من IN</h4><pre><code class='language-sql'>-- أفضل للأداء\nSELECT CustomerName FROM Customers C\nWHERE EXISTS (SELECT 1 FROM Orders O \n              WHERE O.CustomerID = C.CustomerID);\n\n-- أبطأ مع البيانات الكبيرة\nSELECT CustomerName FROM Customers\nWHERE CustomerID IN (SELECT CustomerID FROM Orders);</code></pre><h4>تجنب الاستعلامات المترابطة عند الإمكان</h4><pre><code class='language-sql'>-- بطيء: استعلام مترابط\nSELECT ProductName FROM Products P\nWHERE Price > (SELECT AVG(Price) FROM Products \n              WHERE Category = P.Category);\n\n-- أسرع: استعلام غير مترابط مع JOIN\nSELECT P.ProductName \nFROM Products P\nINNER JOIN (SELECT Category, AVG(Price) AS AvgPrice \n           FROM Products GROUP BY Category) Avg\nON P.Category = Avg.Category\nWHERE P.Price > Avg.AvgPrice;</code></pre><h3>تقليل التعقيد</h3><h4>استخدام CTEs للاستعلامات المعقدة</h4><pre><code class='language-sql'>-- بدلاً من استعلامات متداخلة معقدة\nWITH HighValueCustomers AS (\n    SELECT CustomerID, SUM(TotalAmount) AS TotalSpent\n    FROM Orders\n    GROUP BY CustomerID\n    HAVING SUM(TotalAmount) > 10000\n),\nCustomerOrders AS (\n    SELECT CustomerID, COUNT(*) AS OrderCount\n    FROM Orders\n    GROUP BY CustomerID\n)\nSELECT C.CustomerName, H.TotalSpent, O.OrderCount\nFROM Customers C\nINNER JOIN HighValueCustomers H ON C.CustomerID = H.CustomerID\nINNER JOIN CustomerOrders O ON C.CustomerID = O.CustomerID;</code></pre><h3>ملاحظات عن الـ Indexing وتأثيره</h3><h4>إنشاء فهارس على الأعمدة المستخدمة في الاستعلامات الفرعية</h4><pre><code class='language-sql'>-- إنشاء فهارس لتحسين أداء الاستعلامات الفرعية\nCREATE INDEX idx_orders_customerid ON Orders(CustomerID);\nCREATE INDEX idx_employees_departmentid ON Employees(DepartmentID);</code></pre><h4>مراقبة خطط التنفيذ</h4><pre><code class='language-sql'>-- استخدام EXPLAIN لفهم كيفية تنفيذ الاستعلام\nEXPLAIN SELECT CustomerName FROM Customers\nWHERE CustomerID IN (SELECT CustomerID FROM Orders \n                    WHERE OrderDate >= '2024-01-01');</code></pre><hr><h2>خاتمة</h2><h3>ملخص لأهمية Subquery</h3><p>الاستعلامات الفرعية تُعد أداة قوية ومرنة في SQL تُمكن المطورين من كتابة استعلامات معقدة بطريقة منظمة وقابلة للفهم. رغم أن الـ JOINs قد تكون أسرع في كثير من الحالات، إلا أن الاستعلامات الفرعية توفر وضوحاً في المنطق وسهولة في الصيانة.</p><h3>نصائح للطلاب والمطورين الجدد</h3><ul><li><strong>ابدأ بالأساسيات:</strong> تعلم الاستعلامات الفرعية البسيطة قبل الانتقال للمعقدة.</li><li><strong>فهم الفرق بين الأنواع:</strong> اعرف متى تستخدم correlated vs non-correlated subqueries.</li><li><strong>اختبر الأداء:</strong> قارن دائماً بين الـ subquery والـ JOIN واختر الأنسب.</li><li><strong>استخدم الفهارس:</strong> تأكد من وجود فهارس مناسبة على الأعمدة المستخدمة.</li><li><strong>تجنب التعقيد المفرط:</strong> استخدم CTEs أو قسم الاستعلام إلى خطوات عند الحاجة.</li><li><strong>استخدم EXPLAIN:</strong> لفهم كيفية تنفيذ قاعدة البيانات لاستعلاماتك.</li></ul><p>الممارسة العملية هي أفضل طريقة لإتقان الاستعلامات الفرعية.</p>"
},
{
  "id": "sql-views-guide",
  "link": "posts/sql-views-guide/",
  "title": "العروض (Views) في SQL: دليل شامل ومتخصص",
  "date": "30 أغسطس 2025",
  "readTime": "18 دقيقة",
  "tags": ["SQL", "قواعد البيانات", "شروحات تقنية", "Database Design"],
  "image": "assets/images/sql_views_cover.jpg",
  "excerpt": "دليل متكامل يفصل كل ما تحتاج لمعرفته عن العروض (Views) في SQL، من تبسيط الاستعلامات المعقدة وإدارة الأمان، إلى مقارنتها مع CTEs وأفضل ممارسات الأداء.",
  "author": {
    "name": "عمر بدر",
    "linkedin": "https://www.linkedin.com/in/omarbadrdata/",
    "avatar": "assets/images/omar.jpg"
  },
  "content": "<h2>مقدمة تعريفية</h2><h3>ما هو الـ View في SQL</h3><p>العرض (View) في SQL هو جدول افتراضي يُنشأ بناءً على استعلام SQL محفوظ، ويعمل كنافذة لعرض البيانات من جدول واحد أو أكثر. على عكس الجداول العادية، فإن الـ View لا يحتوي على بيانات فعلية مخزنة فيزيائياً، بل يستعيد البيانات ديناميكياً من الجداول الأساسية عند كل استعلام.</p><p>يمكن التعامل مع الـ View تماماً مثل الجدول العادي في عمليات SELECT، وفي بعض الحالات في عمليات INSERT وUPDATE وDELETE أيضاً، وفقاً لشروط معينة.</p><h3>لماذا نستخدمه، وفائدته في تبسيط الاستعلامات وإخفاء التعقيد</h3><p>استخدام Views في SQL يوفر عدة فوائد مهمة:</p><ul><li><strong>تبسيط الاستعلامات المعقدة</strong>: يمكن إخفاء JOIN المعقدة والاستعلامات الفرعية خلف View بسيط يسهل استخدامه مراراً وتكراراً.</li><li><strong>إخفاء تعقيد هيكل قاعدة البيانات</strong>: يوفر طبقة تجريد بين المستخدمين وهيكل الجداول الفعلي، مما يسمح بتغيير هيكل قاعدة البيانات دون تأثير على التطبيقات.</li><li><strong>تحسين الأمان</strong>: يمكن استخدام Views لإعطاء المستخدمين صلاحية الوصول لأجزاء محددة من البيانات فقط، دون إعطائهم صلاحيات مباشرة على الجداول.</li><li><strong>إعادة الاستخدام والثبات</strong>: يضمن استخدام نفس منطق الاستعلام عبر التطبيقات المختلفة، مما يقلل من التكرار ويحسن الصيانة.</li></ul><h3>الفرق بين الـ View والـ Table العادي</h3><table class=\"data-table\"><thead><tr><th>الخاصية</th><th>View</th><th>Table</th></tr></thead><tbody><tr><td><strong>التخزين الفيزيائي</strong></td><td>لا يحتوي على بيانات مخزنة فيزيائياً</td><td>يحتوي على بيانات مخزنة فيزيائياً</td></tr><tr><td><strong>استهلاك المساحة</strong></td><td>يحفظ تعريف الاستعلام فقط</td><td>يستهلك مساحة تخزين للبيانات</td></tr><tr><td><strong>الأداء</strong></td><td>يُنفذ الاستعلام في كل مرة يُستدعى فيها</td><td>وصول مباشر للبيانات المخزنة</td></tr><tr><td><strong>التحديث</strong></td><td>يعكس التغييرات في الجداول الأساسية تلقائياً</td><td>يتطلب تحديث مباشر</td></tr><tr><td><strong>الفهرسة</strong></td><td>لا يمكن فهرسته (باستثناء Materialized Views)</td><td>يمكن إنشاء فهارس عليه</td></tr></tbody></table><hr><h2>أنواع Views</h2><h3>Simple View مقابل Complex View</h3><h4>Simple View</h4><p>الـ Simple View يعتمد على جدول واحد فقط ولا يحتوي على دوال تجميع، GROUP BY، أو JOIN.</p><pre><code class='language-sql'>-- إنشاء Simple View للموظفين في قسم محدد\nCREATE VIEW IT_Employees AS\nSELECT EmployeeID, EmployeeName, Salary, HireDate\nFROM Employees\nWHERE DepartmentID = 1;\n\n-- استخدام الـ View\nSELECT * FROM IT_Employees\nWHERE Salary > 50000;</code></pre><h4>Complex View</h4><p>الـ Complex View يمكن أن يعتمد على جداول متعددة ويحتوي على JOIN، دوال تجميع، أو تجميع البيانات.</p><pre><code class='language-sql'>-- إنشاء Complex View يجمع معلومات من عدة جداول\nCREATE VIEW Employee_Department_Summary AS\nSELECT \n    D.DepartmentName,\n    COUNT(E.EmployeeID) AS EmployeeCount,\n    AVG(E.Salary) AS AverageSalary\nFROM Departments D\nLEFT JOIN Employees E ON D.DepartmentID = E.DepartmentID\nGROUP BY D.DepartmentID, D.DepartmentName;\n\n-- استخدام الـ View\nSELECT * FROM Employee_Department_Summary\nWHERE EmployeeCount > 5;</code></pre><h3>Read-only View مقابل Updatable View</h3><h4>Read-only View</h4><p>هذا النوع من Views لا يسمح بعمليات INSERT، UPDATE، أو DELETE. ويحدث ذلك عند احتوائه على دوال تجميع, DISTINCT, GROUP BY, أو JOINs.</p><pre><code class='language-sql'>-- Read-only View بسبب وجود دوال التجميع\nCREATE VIEW Sales_Summary AS\nSELECT \n    ProductCategory,\n    COUNT(*) AS TotalSales,\n    SUM(SaleAmount) AS TotalRevenue\nFROM Sales\nGROUP BY ProductCategory;\n\n-- هذا الـ View للقراءة فقط\n-- INSERT INTO Sales_Summary VALUES(...); -- سيفشل</code></pre><h4>Updatable View</h4><p>Views قابلة للتحديث تسمح بعمليات INSERT، UPDATE، وDELETE. يجب أن تعتمد على جدول واحد ولا تحتوي على دوال تجميع أو DISTINCT.</p><pre><code class='language-sql'>-- إنشاء Updatable View للمنتجات النشطة\nCREATE VIEW Active_Products AS\nSELECT ProductID, ProductName, Price, CategoryID\nFROM Products\nWHERE IsActive = 1;\n\n-- يمكن الآن تحديث البيانات من خلاله\nUPDATE Active_Products \nSET Price = 899.99 \nWHERE ProductID = 1;</code></pre><h3>Materialized View</h3><p>الـ Materialized View يختلف جوهرياً عن الـ View العادي، حيث يحفظ نتائج الاستعلام فيزيائياً في قاعدة البيانات، مما يوفر أداءً أسرع للاستعلامات المعقدة ولكنه يتطلب تحديثًا دوريًا.</p><table class=\"data-table\"><thead><tr><th>الخاصية</th><th>View العادي</th><th>Materialized View</th></tr></thead><tbody><tr><td><strong>التخزين</strong></td><td>يحفظ تعريف الاستعلام فقط</td><td>يحفظ نتائج الاستعلام فيزيائياً</td></tr><tr><td><strong>الأداء</strong></td><td>يُنفذ الاستعلام في كل استدعاء</td><td>وصول سريع للبيانات المحفوظة</td></tr><tr><td><strong>التحديث</strong></td><td>يعكس التغييرات فوراً</td><td>يتطلب Refresh دوري أو يدوي</td></tr></tbody></table><pre><code class='language-sql'>-- إنشاء Materialized View (PostgreSQL syntax)\nCREATE MATERIALIZED VIEW Monthly_Sales_Report AS\nSELECT \n    EXTRACT(YEAR FROM OrderDate) AS Year,\n    EXTRACT(MONTH FROM OrderDate) AS Month,\n    COUNT(*) AS OrderCount,\n    SUM(TotalAmount) AS TotalRevenue\nFROM Orders\nGROUP BY 1, 2;\n\n-- يجب تحديثه يدويًا\nREFRESH MATERIALIZED VIEW Monthly_Sales_Report;</code></pre><hr><h2>كيفية إنشاء View</h2><h3>شرح CREATE VIEW مع أمثلة عملية</h3><pre><code class='language-sql'>-- إنشاء View للعملاء النشطين\nCREATE VIEW Active_Customers AS\nSELECT CustomerID, CustomerName, Email, City\nFROM Customers\nWHERE IsActive = 1;\n\n-- View معقد مع JOIN وإحصائيات\nCREATE VIEW Customer_Order_Summary AS\nSELECT \n    C.CustomerID,\n    C.CustomerName,\n    COUNT(O.OrderID) AS TotalOrders,\n    COALESCE(SUM(O.TotalAmount), 0) AS TotalSpent\nFROM Customers C\nLEFT JOIN Orders O ON C.CustomerID = O.CustomerID\nWHERE C.IsActive = 1\nGROUP BY C.CustomerID, C.CustomerName;</code></pre><h3>استخدام WITH CHECK OPTION</h3><p>الـ WITH CHECK OPTION يضمن أن أي عملية INSERT أو UPDATE عبر الـ View تتوافق مع شروط الـ View، مما يمنع إدخال بيانات غير صالحة.</p><pre><code class='language-sql'>CREATE VIEW High_Value_Customers_Safe AS\nSELECT CustomerID, CustomerName, CreditLimit\nFROM Customers\nWHERE CreditLimit >= 10000\nWITH CHECK OPTION;\n\n-- محاولة إدراج عميل بحد ائتمان أقل من 10000 ستفشل\n-- INSERT INTO High_Value_Customers_Safe VALUES (5, 'New Customer', 5000);\n-- Error: WITH CHECK OPTION constraint violated</code></pre><h3>تحديث الـ View باستخدام CREATE OR REPLACE VIEW</h3><p>هذا الأمر يسمح بتعديل تعريف View موجود دون حذفه أولاً.</p><pre><code class='language-sql'>CREATE OR REPLACE VIEW Product_Summary AS\nSELECT \n    ProductID, \n    ProductName, \n    Price,\n    CategoryID\nFROM Products\nWHERE IsActive = 1;</code></pre><hr><h2>استخدامات Views</h2><h3>في تقليل التعقيد (إخفاء جمل JOIN أو Subquery)</h3><p>بدلاً من كتابة استعلام JOIN معقد في كل مرة، يمكنك إنشاء View لتبسيط الأمر.</p><pre><code class='language-sql'>CREATE VIEW Complete_Order_Details AS\nSELECT \n    O.OrderID,\n    C.CustomerName,\n    P.ProductName,\n    OD.Quantity,\n    OD.UnitPrice\nFROM Customers C\nINNER JOIN Orders O ON C.CustomerID = O.CustomerID\nINNER JOIN OrderDetails OD ON O.OrderID = OD.OrderID\nINNER JOIN Products P ON OD.ProductID = P.ProductID;\n\n-- الآن الاستخدام أصبح بسيطاً\nSELECT * FROM Complete_Order_Details\nWHERE CustomerName = 'ABC Company';</code></pre><h3>في إدارة الصلاحيات (إعطاء المستخدمين صلاحية الوصول لجزء من البيانات فقط)</h3><p>يمكنك إنشاء View يعرض فقط الأعمدة غير الحساسة أو الصفوف التي ينتمي إليها مستخدم معين، ثم منح الصلاحية على الـ View بدلاً من الجدول الأساسي.</p><pre><code class='language-sql'>-- View للمديرين - يرون موظفيهم فقط دون البيانات الحساسة\nCREATE VIEW Manager_Employee_View AS\nSELECT \n    EmployeeID,\n    EmployeeName,\n    Position,\n    PerformanceRating\nFROM Employee_Records\nWHERE ManagerID = CURRENT_USER(); -- يعتمد على نظام قاعدة البيانات</code></pre><h3>في إعادة استخدام الاستعلامات بشكل منظم</h3><p>يمكنك إنشاء مكتبة من Views الأساسية (مثل العملاء النشطين، الطلبات الصالحة) ثم استخدامها لبناء Views تحليلية أكثر تعقيدًا فوقها.</p><hr><h2>الفرق بين View و Table و CTE</h2><table class=\"data-table\"><thead><tr><th>الخاصية</th><th>View</th><th>Table</th><th>CTE</th></tr></thead><tbody><tr><td><strong>النوع</strong></td><td>كائن قاعدة بيانات افتراضي</td><td>كائن قاعدة بيانات فيزيائي</td><td>تعبير مؤقت في الاستعلام</td></tr><tr><td><strong>دورة الحياة</strong></td><td>دائم حتى يُحذف</td><td>دائم حتى يُحذف</td><td>يزول بانتهاء الاستعلام</td></tr><tr><td><strong>إعادة الاستخدام</strong></td><td>عبر استعلامات متعددة</td><td>عبر استعلامات متعددة</td><td>فقط داخل الاستعلام نفسه</td></tr></tbody></table><h3>متى نستخدم View بدل CTE</h3><p>استخدم <strong>View</strong> عندما تحتاج لإعادة استخدام نفس المنطق في استعلامات متعددة أو لتطبيق طبقة أمان. استخدم <strong>CTE</strong> لتقسيم استعلام معقد لمرة واحدة أو للتعامل مع الاستعلامات التكرارية (Recursive).</p><hr><h2>أفضل الممارسات (Best Practices)</h2><ul><li><strong>استخدم أسماء وصفية:</strong> ابدأ اسم الـ View بـ `vw_` أو `v_` لتمييزه.</li><li><strong>اختر الأعمدة المطلوبة فقط:</strong> تجنب استخدام `SELECT *` في تعريف الـ View لتحسين الأداء.</li><li><strong>تجنب التداخل المفرط:</strong> لا تبني Views فوق Views أخرى لأكثر من 2-3 مستويات لتجنب مشاكل الأداء.</li><li><strong>استخدم الفهارس على الجداول الأساسية:</strong> أداء الـ View يعتمد بشكل مباشر على أداء الاستعلام الأساسي، لذا تأكد من وجود فهارس مناسبة.</li></ul><h2>خاتمة</h2><p>الـ Views في SQL هي أداة استراتيجية لبناء أنظمة قواعد بيانات قابلة للصيانة، التطوير، والأمان. إتقانها يأتي مع الممارسة والفهم العميق لمتطلبات كل مشروع، واختيار النوع المناسب من Views لكل حالة استخدام.</p>"
},
{
  "id": "sql-cte-guide",
  "link": "posts/sql-cte-guide/",
  "title": "دليل شامل حول الـ Common Table Expressions (CTEs) في SQL",
  "date": "05 سبتمبر 2025",
  "readTime": "12 دقيقة",
  "tags": ["SQL", "قواعد البيانات", "شروحات تقنية", "CTE"],
  "image": "assets/images/sql_cte_cover.jpg",
  "excerpt": "دليل متكامل يفصل كل ما تحتاج لمعرفته عن الـ Common Table Expressions (CTEs) في SQL، من البناء الأساسي والاستخدامات العملية إلى المقارنة مع الأدوات الأخرى.",
  "author": {
    "name": "عمر بدر",
    "linkedin": "https://www.linkedin.com/in/omarbadrdata/",
    "avatar": "assets/images/omar.jpg"
  },
  "content": "<h2>مقدمة: تعريف الـ CTE وأهميته</h2><p>الـ Common Table Expression (CTE) هو تعبير عن مجموعة بيانات مؤقتة (نتيجة استعلام)، يُعرف باسم داخل جملة WITH، ويعمل داخل مدى (scope) استعلام واحد فقط. يشبه الـ CTE <em>جدولاً افتراضياً مؤقتاً</em> يمكن الرجوع إليه بواسطة الاستعلام الرئيسي، ما يؤدي إلى كتابة استعلامات نظيفة وأكثر وضوحاً وسهولة عند إدارة عمليات معقدة.</p><h3>الفرق بين CTE وSubquery وView</h3><ul><li><strong>Subquery:</strong> استعلام فرعي يُكتب داخل استعلام أكبر، غالباً يجلب بيانات مؤقتة ولا يسمح بسهولة بإعادة الاستخدام أو البناء المنظم للمنطق.</li><li><strong>View:</strong> عبارة عن استعلام محفوظ في قاعدة البيانات، صالح للاستخدام عبر عدة استعلامات، لكنه ثابت في هيكله ويحتاج صلاحيات لإنشائه.</li><li><strong>CTE:</strong> مؤقت، يُعرف ضمن مدى استعلام واحد بجملة WITH، يُمكّن من تقسيم الاستعلامات الكبيرة إلى مراحل واضحة وقابلة للفهم، ويُستخدم مرة واحدة فقط في التنفيذ.</li></ul><h3>لماذا نستخدم CTE؟</h3><ul><li>تسهيل قراءة الاستعلامات المعقدة.</li><li>تقسيم العمليات إلى خطوات واضحة.</li><li>استخدامه داخل عمليات JOIN وAggregate بدون تكرار الكود.</li><li>إمكانية إنشاء CTEs متكررة (recursive) للتعامل مع التركيبات الهرمية أو الحسابات المتكررة.</li></ul><hr><h2>البناء الأساسي (Syntax)</h2><h3>جملة WITH</h3><p>الشكل الأساسي لجملة CTE كالتالي:</p><pre><code class='language-sql'>WITH cte_name [ (column_1, column_2, ...) ] AS (\n    -- Select statement يعطي نتيجة مؤقتة\n    SELECT ...\n)\nSELECT ... FROM cte_name;</code></pre><h3>مثال مبسط على CTE مع SELECT</h3><pre><code class='language-sql'>WITH CustomersInCairo AS (\n    SELECT CustomerID, CustomerName\n    FROM Customers\n    WHERE City = 'Cairo'\n)\nSELECT * FROM CustomersInCairo;</code></pre><p>هنا يتم تعريف مجموعة بيانات مؤقتة باسم CustomersInCairo، ثم استخدمها في الاستعلام الرئيسي.</p><hr><h2>أنواع CTE</h2><h3>Non-recursive CTE</h3><p>وهو النوع الأساسي، عبارة عن نتيجة استعلام مؤقتة استخدمها مباشرة مرة واحدة في الاستعلام.</p><pre><code class='language-sql'>WITH HighSalaryEmployees AS (\n    SELECT EmployeeID, EmployeeName, Salary\n    FROM Employees\n    WHERE Salary > 7000\n)\nSELECT * FROM HighSalaryEmployees;</code></pre><h3>Recursive CTE (النوع المتكرر)</h3><p>يتيح استخدام الـ CTE بشكل متكرر مع نفسه داخلياً، عادة لأغراض بناء تسلسل أو هرمية.</p><h4>تركيبة Recursive:</h4><ul><li><em>Recursive Anchor Member</em>: الجزء الأول الأساسي من البيانات.</li><li><em>Recursive Member</em>: عملية تربط النتائج السابقة بالخطوة الجديدة.</li></ul><pre><code class='language-sql'>-- مثال: حساب تسلسل الأرقام 1 إلى 10\nWITH NumbersCTE (n) AS (\n    SELECT 1  -- Anchor\n    UNION ALL\n    SELECT n + 1 FROM NumbersCTE WHERE n < 10  -- Recursive member\n)\nSELECT * FROM NumbersCTE;</code></pre><hr><h2>استخدامات عملية للـ CTE</h2><h3>تبسيط الاستعلامات المعقدة</h3><p>بدلاً من استخدام Subqueries متداخلة، يمكن تعريف أكثر من CTE لتحقيق خطوات متتابعة تسمح بفهم منطقي للاستعلام.</p><pre><code class='language-sql'>WITH Sales2024 AS (\n    SELECT OrderID, CustomerID, TotalAmount\n    FROM Orders\n    WHERE YEAR(OrderDate) = 2024\n),\nTopCustomers AS (\n    SELECT CustomerID, SUM(TotalAmount) AS TotalPurchase\n    FROM Sales2024\n    GROUP BY CustomerID\n    HAVING SUM(TotalAmount) > 10000\n)\nSELECT * FROM TopCustomers;</code></pre><h3>استخدام CTE مع JOIN</h3><pre><code class='language-sql'>WITH RecentOrders AS (\n    SELECT OrderID, CustomerID, OrderDate\n    FROM Orders\n    WHERE OrderDate > DATEADD(MONTH, -1, GETDATE())\n)\nSELECT C.CustomerName, R.OrderDate\nFROM Customers C\nJOIN RecentOrders R ON C.CustomerID = R.CustomerID;</code></pre><h3>استخدام CTE في INSERT / UPDATE / DELETE</h3><h4>INSERT:</h4><pre><code class='language-sql'>WITH NewCustomers AS (\n    SELECT CustomerID, CustomerName\n    FROM ImportCustomers\n    WHERE IsVerified = 1\n)\nINSERT INTO Customers (CustomerID, CustomerName)\nSELECT CustomerID, CustomerName FROM NewCustomers;</code></pre><h4>UPDATE:</h4><pre><code class='language-sql'>WITH UnderstockedProducts AS (\n    SELECT ProductID FROM Products WHERE StockQuantity < 5\n)\nUPDATE Products\nSET IsActive = 0\nWHERE ProductID IN (SELECT ProductID FROM UnderstockedProducts);</code></pre><h4>DELETE:</h4><pre><code class='language-sql'>WITH ExpiredOrders AS (\n    SELECT OrderID FROM Orders WHERE Status = 'Expired'\n)\nDELETE FROM Orders\nWHERE OrderID IN (SELECT OrderID FROM ExpiredOrders);</code></pre><hr><h2>Recursive CTE بالتفصيل</h2><h3>مثال على بيانات هرمية (شجرة الموظفين والمديرين):</h3><pre><code class='language-sql'>WITH EmployeeHierarchy AS (\n    SELECT EmployeeID, ManagerID, EmployeeName, 1 AS Level\n    FROM Employees\n    WHERE ManagerID IS NULL  -- المدراء الأعلى\n    UNION ALL\n    SELECT e.EmployeeID, e.ManagerID, e.EmployeeName, eh.Level + 1\n    FROM Employees e\n    INNER JOIN EmployeeHierarchy eh ON e.ManagerID = eh.EmployeeID\n)\nSELECT * FROM EmployeeHierarchy\nORDER BY Level, EmployeeID;</code></pre><hr><h2>المقارنة: CTE مقابل Subquery مقابل View</h2><table class=\"data-table\"><thead><tr><th>الميزة</th><th>CTE</th><th>Subquery</th><th>View</th></tr></thead><tbody><tr><td><strong>التخزين</strong></td><td>مؤقت، داخل الاستعلام</td><td>مؤقت، داخل الاستعلام</td><td>دائم في قاعدة البيانات</td></tr><tr><td><strong>إعادة الاستخدام</strong></td><td>لا</td><td>لا</td><td>نعم</td></tr><tr><td><strong>التعقيد</strong></td><td>يقسم الاستعلامات</td><td>متداخل وأحياناً غير واضح</td><td>واضح للاستخدام المتكرر</td></tr><tr><td><strong>دعم Recursion</strong></td><td>نعم</td><td>لا</td><td>لا</td></tr></tbody></table><h3>متى تستخدم؟</h3><ul><li><strong>CTE:</strong> لتحسين وضوح الاستعلام المعقد مرة واحدة، أو عندما تحتاج عمليات تكرارية (تسلسل/شجرة).</li><li><strong>Subquery:</strong> للحالات البسيطة أو عندما تحتاج استعلام داخلي مباشر.</li><li><strong>View:</strong> للاستخدامات المتكررة أو إخفاء التعقيد عن المستخدم النهائي.</li></ul><hr><h2>أفضل الممارسات (Best Practices)</h2><ul><li><strong>استخدم أسماء واضحة للـ CTE:</strong> اختر أسماء تصف محتوى ودور الـ CTE بوضوح.</li><li><strong>تجنب التداخل المفرط للـ CTE:</strong> استخدم من 1-3 مستويات كحد أقصى في الاستعلام.</li><li><strong>اهتم بالأداء في Recursive CTE:</strong> أضف شرط إيقاف واضح لمنع التكرار اللانهائي.</li></ul><hr><h2>خاتمة</h2><p>الـ CTE في SQL هو أداة متقدمة تساعد المطورين على كتابة استعلامات أكثر تنظيماً ووضوحاً، خصوصاً في حالات المنطق المعقد أو التركيبات الهرمية. عند استخدامها وفق أفضل الممارسات، يصبح التحليل والتطوير أسرع وأقل عرضة للأخطاء.</p><p><strong>نصيحتي للمطورين:</strong> استخدم الـ CTE كأداة لتوضيح المنطق وتقسيم الحلول، وتذكر أنها من أقوى أسلحتك لبناء استعلامات SQL تسهل عليك التطوير وتبقي شيفرتك منظمة وقوية.</p>"
},
{
  "id": "sql-window-functions-guide",
  "link": "posts/sql-window-functions-guide/",
  "title": "دليل شامل حول SQL Window Functions",
  "date": "10 سبتمبر 2025",
  "readTime": "15 دقيقة",
  "tags": ["SQL", "تحليل بيانات", "شروحات تقنية"],
  "image": "assets/images/sql_window_functions_cover.jpg",
  "excerpt": "دليل متكامل يفصل كل ما تحتاج لمعرفته عن وظائف النوافذ (Window Functions) في SQL، من دوال الترتيب والتراكم إلى الحالات المتقدمة وأفضل الممارسات.",
  "author": {
    "name": "عمر بدر",
    "linkedin": "https://www.linkedin.com/in/omarbadrdata/",
    "avatar": "assets/images/omar.jpg"
  },
  "content": "<h2>مقدمة واضحة</h2><h3>تعريف SQL Window Functions</h3><p>وظائف النوافذ (Window Functions) في SQL هي مجموعة من الدوال التحليلية التي تعمل على مجموعة فرعية من الصفوف (تُسمى نافذة) ضمن نتائج استعلام دون دمج الصفوف معًا في نتيجة مجمعة واحدة. تمكن هذه الوظائف من إجراء حسابات تراكمية، إحصائيات ترتيبية، وغيرها من العمليات التحليلية بطريقة أكثر مرونة من دوال التجميع التقليدية.</p><h3>أهميتها ولماذا تُستخدم</h3><p>تُستخدم Window Functions بشكل واسع لأنها تسمح بإجراء تحليلات متقدمة ضمن نفس الاستعلام، مثل حساب المتوسط المتحرك، الترتيب داخل مجموعة معينة، ومقارنة كل صف مع الصفوف المجاورة له، كل ذلك دون الحاجة لاستعلامات فرعية معقدة.</p><h3>الفرق بين Window Functions والبدائل الأخرى</h3><table class=\"data-table\"><thead><tr><th>الميزة</th><th>Window Function</th><th>Aggregate Function</th><th>Subquery / Join</th></tr></thead><tbody><tr><td><strong>المحافظة على الصفوف</strong></td><td><span class='check-mark'>✓</span> نعم، كل صف يبقى منفصلاً</td><td><span class='cross-mark'>✗</span> لا، تقوم بدمج الصفوف</td><td><span class='check-mark'>✓</span> نعم، لكنها قد تكرر الصفوف</td></tr><tr><td><strong>التحليل داخل مجموعة</strong></td><td><span class='check-mark'>✓</span> مصممة لهذا الغرض (مع PARTITION BY)</td><td><span class='cross-mark'>✗</span> تتطلب GROUP BY وتفقد التفاصيل</td><td><span class='cross-mark'>✗</span> ممكن، لكنه معقد ويتطلب استعلامات مترابطة</td></tr><tr><td><strong>الأداء</strong></td><td><span class='check-mark'>✓</span> عالي الكفاءة ومصمم للتحليلات</td><td><span class='check-mark'>✓</span> سريع للتجميع البسيط</td><td><span class='cross-mark'>✗</span> قد يكون بطيئًا جدًا في الحالات المعقدة</td></tr></tbody></table><hr><h2>الأنواع الأساسية لوظائف النوافذ</h2><h3>1. دوال الترتيب (Ranking Functions)</h3><ul><li><strong>ROW_NUMBER():</strong> تعطي رقمًا تسلسليًا فريدًا لكل صف.</li><li><strong>RANK():</strong> تعطي ترتيبًا مع ترك فجوات في حالة القيم المتساوية (1, 2, 2, 4).</li><li><strong>DENSE_RANK():</strong> تعطي ترتيبًا بدون فجوات في حالة القيم المتساوية (1, 2, 2, 3).</li><li><strong>NTILE(n):</strong> تقسم الصفوف إلى عدد (n) من المجموعات المتساوية تقريبًا.</li></ul><pre><code class='language-sql'>-- ترتيب الموظفين حسب الراتب داخل كل قسم\nSELECT EmployeeName, DepartmentID, Salary,\n       ROW_NUMBER() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS RowNum,\n       RANK() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS RankNum,\n       DENSE_RANK() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS DenseRankNum\nFROM Employees;</code></pre><h3>2. دوال التراكم (Aggregate Window Functions)</h3><p>استخدام دوال التجميع المعروفة (SUM, AVG, COUNT) مع جملة <code>OVER()</code> لتطبيقها على نافذة محددة.</p><pre><code class='language-sql'>-- حساب مجموع ومتوسط رواتب كل قسم مع الاحتفاظ ببيانات كل موظف\nSELECT EmployeeName, DepartmentID, Salary,\n       SUM(Salary) OVER (PARTITION BY DepartmentID) AS DepartmentTotalSalary,\n       AVG(Salary) OVER (PARTITION BY DepartmentID) AS DepartmentAvgSalary\nFROM Employees;</code></pre><h3>3. دوال القيمة النسبية (Value Functions)</h3><ul><li><strong>LAG():</strong> للحصول على قيمة من صف سابق.</li><li><strong>LEAD():</strong> للحصول على قيمة من صف لاحق.</li><li><strong>FIRST_VALUE():</strong> للحصول على أول قيمة في النافذة.</li><li><strong>LAST_VALUE():</strong> للحصول على آخر قيمة في النافذة.</li></ul><pre><code class='language-sql'>-- مقارنة مبيعات الشهر الحالي مع الشهر السابق\nSELECT SalesMonth, MonthlyRevenue,\n       LAG(MonthlyRevenue, 1, 0) OVER (ORDER BY SalesMonth) AS PreviousMonthRevenue\nFROM MonthlySales;</code></pre><hr><h2>أمثلة عملية مع الشرح</h2><h3>مثال 1: إيجاد أعلى 3 موظفين راتبًا في كل قسم</h3><pre><code class='language-sql'>WITH RankedEmployees AS (\n    SELECT EmployeeName, DepartmentID, Salary,\n           ROW_NUMBER() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS rn\n    FROM Employees\n)\nSELECT *\nFROM RankedEmployees\nWHERE rn <= 3;</code></pre><h3>مثال 2: حساب المجموع التراكمي للمبيعات (Running Total)</h3><pre><code class='language-sql'>SELECT OrderDate, TotalAmount,\n       SUM(TotalAmount) OVER (ORDER BY OrderDate) AS RunningTotalSales\nFROM Orders;</code></pre><h3>مثال 3: حساب النسبة المئوية لكل منتج من إجمالي المبيعات</h3><pre><code class='language-sql'>SELECT ProductName, ProductSales,\n       (ProductSales * 100.0 / SUM(ProductSales) OVER ()) AS PercentageOfTotal\nFROM ProductSalesSummary;</code></pre><hr><h2>أفضل الممارسات (Best Practices)</h2><h3>1. استخدم PARTITION BY بحكمة</h3><p>جملة <code>PARTITION BY</code> هي قلب وظائف النوافذ. استخدمها دائمًا لتقسيم تحليلاتك إلى مجموعات منطقية (مثل الأقسام، المدن، فئات المنتجات). هذا هو ما يمنحها قوتها الحقيقية.</p><h3>2. اجمعها مع CTEs للوضوح</h3><p>الاستعلامات التي تحتوي على وظائف النوافذ قد تصبح طويلة. استخدام Common Table Expressions (CTEs) لتقسيم الاستعلام إلى خطوات منطقية يجعل الكود أكثر تنظيمًا وسهولة في القراءة والصيانة.</p><pre><code class='language-sql'>WITH MonthlySales AS (\n    -- الخطوة الأولى: تجميع المبيعات الشهرية\n    SELECT ...\n)\n-- الخطوة الثانية: تطبيق وظائف النوافذ على النتائج المجمعة\nSELECT \n    *,\n    LAG(MonthlyTotal) OVER (ORDER BY SalesMonth) AS PrevMonthSales\nFROM MonthlySales;</code></pre><h3>3. انتبه لإطار النافذة (Window Frame)</h3><p>في الحسابات التراكمية، كن دقيقًا في تحديد إطار النافذة. الجملة الافتراضية قد لا تعطيك النتيجة المرجوة دائمًا. استخدم <code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code> لضمان حساب المجموع التراكمي بشكل صحيح.</p><h3>4. استخدم الفهارس (Indexes)</h3><p>أداء وظائف النوافذ يعتمد بشكل كبير على سرعة ترتيب البيانات. تأكد من وجود فهارس (Indexes) على الأعمدة المستخدمة في جملة <code>PARTITION BY</code> و <code>ORDER BY</code> لتحقيق أفضل أداء.</p><hr><h2>الخاتمة</h2><p>وظائف النوافذ في SQL هي نقلة نوعية عن دوال التجميع التقليدية. هي تمنحك القدرة على إجراء تحليلات معقدة ومقارنات داخل مجموعات البيانات مع الحفاظ على تفاصيل كل صف. إتقان هذه الدوال، وخصوصًا عند دمجها مع CTEs، هو مهارة أساسية ومتقدمة تميز محلل البيانات المحترف وتفتح الباب أمام رؤى أعمق وأكثر دقة.</p>"
},
{
  "id": "sql-over-clause-guide",
  "link": "posts/sql-over-clause-guide/",
  "title": "دليل شامل لشرح دالة OVER() في SQL",
  "date": "15 سبتمبر 2025",
  "readTime": "9 دقائق",
  "tags": ["SQL", "Window Functions", "شروحات تقنية"],
  "image": "assets/images/sql_over_clause_cover.png",
  "excerpt": "دليل مفصل وعملي يشرح كيفية استخدام دالة OVER() مع دوال النوافذ التحليلية مثل LAG, LEAD, RANK, و NTILE لتحسين استعلامات SQL الخاصة بك.",
  "author": {
    "name": "عمر بدر",
    "linkedin": "https://www.linkedin.com/in/omarbadrdata/",
    "avatar": "assets/images/omar.jpg"
  },
  "content": "<h2>مقدمة: ما هي دالة OVER() في SQL؟</h2><p>دالة <strong>OVER()</strong> هي حجر الزاوية في وظائف النوافذ (Window Functions). هي لا تقوم بأي حساب بنفسها، بل تُنشئ \"نافذة\" (Window) أو مجموعة فرعية من الصفوف لكل صف في نتيجة الاستعلام. بعد ذلك، يمكن تطبيق دوال تحليلية (مثل SUM, RANK, LAG) على هذه النافذة، مما يسمح بإجراء حسابات تراكمية أو ترتيبية مع الحفاظ على تفاصيل كل صف على حدة.</p><hr><h2>استخدامات مهمة مع أمثلة عملية</h2><h3>1. دوال الوصول للصفوف المجاورة: LAG و LEAD</h3><p>تمكنك هذه الدوال من \"النظر\" إلى الصفوف السابقة أو اللاحقة بالنسبة للصف الحالي داخل النافذة، وهي مفيدة للغاية في تحليلات السلاسل الزمنية والمقارنات.</p><h4>مثال: تتبع المدن المستضيفة للأولمبياد</h4><pre><code class='language-sql'>WITH Hosts AS (\n  SELECT DISTINCT Year, City\n  FROM Summer_Medals\n)\nSELECT \n  Year, City,\n  LEAD(City, 1) OVER (ORDER BY Year ASC) AS Next_City,\n  LEAD(City, 2) OVER (ORDER BY Year ASC) AS After_Next_City\nFROM Hosts\nORDER BY Year ASC;</code></pre><ul><li><code>LEAD(City, 1) OVER (ORDER BY Year ASC)</code>: لكل صف، تعرض هذه الدالة قيمة عمود <code>City</code> من الصف التالي مباشرة (بفارق صف واحد)، بناءً على ترتيب الأعوام تصاعديًا.</li><li><code>LEAD(City, 2)</code>: تعرض المدينة التي ستستضيف بعد دورتين.</li></ul><h3>2. دوال القيمة الأولى والأخيرة: FIRST_VALUE و LAST_VALUE</h3><p>تُستخدم هذه الدوال للحصول على القيمة الأولى أو الأخيرة ضمن إطار النافذة المحدد.</p><h4>مثال: تحديد أول وآخر مدينة مستضيفة</h4><pre><code class='language-sql'>SELECT \n  Year, City,\n  FIRST_VALUE(City) OVER (ORDER BY Year ASC) AS First_City,\n  LAST_VALUE(City) OVER (\n    ORDER BY Year ASC\n    RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS Last_City\nFROM Hosts\nORDER BY Year ASC;</code></pre><ul><li><code>FIRST_VALUE(City)</code>: تعرض دائمًا أول مدينة في مجموعة البيانات بأكملها ('Athens').</li><li><code>LAST_VALUE(City)</code>: لعرض آخر قيمة بشكل صحيح، يجب تحديد إطار النافذة ليشمل كل الصفوف من البداية إلى النهاية باستخدام <code>RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code>.</li></ul><h3>3. دوال الترتيب: ROW_NUMBER, RANK, و DENSE_RANK</h3><p>هذه الدوال أساسية لترتيب وتصنيف البيانات داخل مجموعات.</p><ul><li><strong>ROW_NUMBER():</strong> يعطي رقمًا تسلسليًا فريدًا لكل صف.</li><li><strong>RANK():</strong> يعطي نفس الترتيب للقيم المتساوية ثم يترك فجوة في الترقيم.</li><li><strong>DENSE_RANK():</strong> يعطي نفس الترتيب للقيم المتساوية ولكن بدون ترك فجوات.</li></ul><h4>مثال: تصنيف الدول حسب عدد المشاركات</h4><pre><code class='language-sql'>WITH Country_Games AS (\n  SELECT Country, COUNT(DISTINCT Year) AS Games\n  FROM Summer_Medals\n  WHERE Country IN ('GBR', 'DEN', 'FRA', 'ITA', 'AUT', 'BEL', 'NOR', 'POL', 'ESP')\n  GROUP BY Country\n)\nSELECT \n  Country, Games,\n  ROW_NUMBER() OVER (ORDER BY Games DESC) AS Row_N,\n  RANK() OVER (ORDER BY Games DESC) AS Rank_N,\n  DENSE_RANK() OVER (ORDER BY Games DESC) AS Dense_Rank_N\nFROM Country_Games\nORDER BY Games DESC, Country ASC;</code></pre><p>هذا المثال يوضح ببراعة الفروق الدقيقة بين دوال الترتيب الثلاث، خاصة عند التعامل مع قيم متساوية في عمود <code>Games</code>.</p><h3>4. دالة NTILE لتقسيم البيانات (Paging)</h3><p>تُستخدم لتقسيم مجموعة من الصفوف إلى عدد محدد من المجموعات المتساوية تقريبًا، وهي مفيدة جدًا في تصنيف البيانات (مثل تقسيم العملاء إلى شرائح).</p><h4>مثال: تقسيم الدول إلى ثلاث فئات حسب الميداليات</h4><pre><code class='language-sql'>WITH Country_Medals AS ( \n  SELECT Country, COUNT(*) AS Medals \n  FROM Summer_Medals \n  GROUP BY Country\n)\nSELECT \n  Country, Medals,\n  NTILE(3) OVER (ORDER BY Medals DESC) AS Third\nFROM Country_Medals;</code></pre><p>هنا، يتم تصنيف الدول إلى ثلاث فئات (أعلى ثلث، أوسط ثلث، وأقل ثلث) بناءً على إجمالي عدد الميداليات التي حصلت عليها.</p><hr><h2>خلاصة</h2><p>دالة <strong>OVER()</strong> هي مفتاح استخدام وظائف النوافذ التحليلية في SQL. هي تسمح بتطبيق دوال معقدة على \"نافذة\" محددة من البيانات دون الحاجة إلى تجميع الصفوف، مما يفتح الباب أمام تحليلات متقدمة داخل استعلام واحد.</p><p>قدراتها تشمل:</p><ul><li>ترتيب وتصنيف الصفوف (<code>ROW_NUMBER</code>, <code>RANK</code>).</li><li>الوصول إلى بيانات من صفوف أخرى (<code>LEAD</code>, <code>LAG</code>).</li><li>حساب القيم التراكمية (<code>SUM() OVER (...)</code>).</li><li>تقسيم البيانات إلى مجموعات متساوية (<code>NTILE</code>).</li></ul><p>هذه الأمثلة العملية توضح قوة ودقة وظائف النوافذ، وتعتبر مهارة لا غنى عنها في تحليلات قواعد البيانات المتقدمة.</p>"
},
{
  "id": "postgresql-window-functions-deep-dive",
  "link": "posts/postgresql-window-functions-deep-dive/",
  "title": "دوال النوافذ في PostgreSQL: شرح تفصيلي وأمثلة عملية",
  "date": "20 سبتمبر 2025",
  "readTime": "11 دقيقة",
  "tags": ["SQL", "PostgreSQL", "Data Analysis", "شروحات تقنية"],
  "image": "assets/images/postgresql_window_functions_cover.png",
  "excerpt": "دليل متقدم يشرح بالتفصيل كيفية استخدام دوال النوافذ في PostgreSQL، من الحسابات التراكمية و PARTITION BY إلى المتوسطات المتحركة والفرق بين ROWS و RANGE.",
  "author": {
    "name": "عمر بدر",
    "linkedin": "https://www.linkedin.com/in/omarbadrdata/",
    "avatar": "assets/images/omar.jpg"
  },
  "content": "<h2>مقدمة</h2><p>دوال النوافذ (Window Functions) هي أدوات قوية في SQL تتيح إجراء عمليات تحليلية متقدمة على مجموعات معينة من الصفوف المرتبطة بكل صف في نتيجة الاستعلام، دون الحاجة لتجميع البيانات بشكل دائم. توفر هذه الدوال إمكانات متقدمة لتحليل المتغيرات الإحصائية، التصنيف، الترتيب، والحسابات التراكمية بطريقة مرنة وفعالة.</p><hr><h2>1. دوال التجميع التراكمية (Aggregate Window Functions)</h2><p>تُستخدم هذه الدوال لحساب قيم تراكمية أو تحليلية عبر نافذة محددة من الصفوف، مثل:</p><ul><li><strong>MAX():</strong> تعطي أكبر قيمة في النافذة.</li><li><strong>SUM():</strong> تعطي مجموع القيم.</li><li><strong>AVG():</strong> المتوسط الحسابي.</li><li><strong>COUNT():</strong> عدد الصفوف.</li></ul><h3>مثال عملي: حساب الميداليات الذهبية للبرازيل عبر السنوات</h3><pre><code class='language-sql'>WITH Brazil_Medals AS (\n  SELECT Year, COUNT(*) AS Medals\n  FROM Summer_Medals\n  WHERE Country = 'BRA' AND Medal = 'Gold' AND Year >= 1992\n  GROUP BY Year\n  ORDER BY Year\n)\nSELECT \n  Year, \n  Medals,\n  MAX(Medals) OVER (ORDER BY Year) AS Max_Medals,\n  SUM(Medals) OVER (ORDER BY Year) AS Cumulative_Medals\nFROM Brazil_Medals;</code></pre><p><strong>النتيجة:</strong></p><table class=\"data-table\"><thead><tr><th>Year</th><th>Medals</th><th>Max_Medals</th><th>Cumulative_Medals</th></tr></thead><tbody><tr><td>1992</td><td>13</td><td>13</td><td>13</td></tr><tr><td>1996</td><td>5</td><td>13</td><td>18</td></tr><tr><td>2004</td><td>18</td><td>18</td><td>36</td></tr><tr><td>2008</td><td>14</td><td>18</td><td>50</td></tr><tr><td>2012</td><td>14</td><td>18</td><td>64</td></tr></tbody></table><hr><h2>2. تقسيم البيانات باستخدام PARTITION BY</h2><p>يمكن تقسيم البيانات إلى مجموعات مستقلة عن بعضها عبر <strong>PARTITION BY</strong> داخل دالة النوافذ، مما يسمح بحساب القيم بشكل منفصل لكل مجموعة.</p><h3>مثال: تجميع الميداليات حسب الدولة والسنوات</h3><pre><code class='language-sql'>WITH Medals AS (\n  SELECT Year, Country, COUNT(*) AS Medals\n  FROM Summer_Medals\n  WHERE Medal = 'Gold'\n  GROUP BY Year, Country\n)\nSELECT\n  Year,\n  Country,\n  Medals,\n  SUM(Medals) OVER (PARTITION BY Country ORDER BY Year) AS Country_Cumulative_Medals\nFROM Medals\nORDER BY Country, Year;</code></pre><p><strong>النتيجة:</strong></p><table class=\"data-table\"><thead><tr><th>Year</th><th>Country</th><th>Medals</th><th>Country_Cumulative_Medals</th></tr></thead><tbody><tr><td>2004</td><td>BRA</td><td>18</td><td>18</td></tr><tr><td>2008</td><td>BRA</td><td>14</td><td>32</td></tr><tr><td>2012</td><td>BRA</td><td>14</td><td>46</td></tr><tr><td>2004</td><td>CUB</td><td>31</td><td>31</td></tr><tr><td>2008</td><td>CUB</td><td>2</td><td>33</td></tr><tr><td>2012</td><td>CUB</td><td>5</td><td>38</td></tr></tbody></table><hr><h2>3. إطارات الصفوف (Frames): التحكم في نطاق العمليات</h2><p>يتم التحكم في نطاق الصفوف التي تؤثر على الحسابات باستخدام جملة محددة داخل OVER مثل <code>ROWS BETWEEN X PRECEDING AND Y FOLLOWING</code>.</p><h3>مثال: MAX مع إطار صفوف محدود</h3><pre><code class='language-sql'>WITH Russia_Medals AS (\n  SELECT Year, COUNT(*) AS Medals\n  FROM Summer_Medals\n  WHERE Country = 'RUS' AND Medal = 'Gold'\n  GROUP BY Year\n  ORDER BY Year\n)\nSELECT\n  Year,\n  Medals,\n  MAX(Medals) OVER (ORDER BY Year) AS Max_Overall,\n  MAX(Medals) OVER (ORDER BY Year ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Max_Last2\nFROM Russia_Medals;</code></pre><p><strong>النتيجة:</strong></p><table class=\"data-table\"><thead><tr><th>Year</th><th>Medals</th><th>Max_Overall</th><th>Max_Last2</th></tr></thead><tbody><tr><td>1996</td><td>36</td><td>36</td><td>36</td></tr><tr><td>2000</td><td>66</td><td>66</td><td>66</td></tr><tr><td>2004</td><td>47</td><td>66</td><td>66</td></tr><tr><td>2008</td><td>43</td><td>66</td><td>47</td></tr><tr><td>2012</td><td>47</td><td>66</td><td>47</td></tr></tbody></table><hr><h2>4. المتوسطات والمجاميع المتحركة (Moving Averages and Totals)</h2><p>تُستخدم هذه لتحديد الاتجاهات عبر فترة زمنية معينة، مثل حساب المتوسط أو المجموع لعدد معين من الصفوف قبل أو بعد الصف الحالي.</p><h3>مثال: المتوسط المتحرك لعدد الميداليات خلال 3 دورات أولمبية</h3><pre><code class='language-sql'>WITH US_Medals AS (\n  SELECT Year, COUNT(*) AS Medals\n  FROM Summer_Medals\n  WHERE Country = 'USA' AND Medal = 'Gold' AND Year >= 1980\n  GROUP BY Year\n  ORDER BY Year\n)\nSELECT \n  Year,\n  Medals,\n  AVG(Medals) OVER (ORDER BY Year ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS Moving_Avg,\n  SUM(Medals) OVER (ORDER BY Year ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS Moving_Sum\nFROM US_Medals;</code></pre><p><strong>النتيجة:</strong></p><table class=\"data-table\"><thead><tr><th>Year</th><th>Medals</th><th>Moving_Avg</th><th>Moving_Sum</th></tr></thead><tbody><tr><td>1984</td><td>168</td><td>168.00</td><td>168</td></tr><tr><td>1988</td><td>77</td><td>122.50</td><td>245</td></tr><tr><td>1992</td><td>89</td><td>111.33</td><td>334</td></tr><tr><td>1996</td><td>160</td><td>108.67</td><td>326</td></tr><tr><td>2000</td><td>130</td><td>126.33</td><td>379</td></tr><tr><td>2004</td><td>116</td><td>135.33</td><td>406</td></tr><tr><td>2008</td><td>125</td><td>123.67</td><td>371</td></tr><tr><td>2012</td><td>147</td><td>129.33</td><td>388</td></tr></tbody></table><hr><h2>5. الفرق بين ROWS و RANGE</h2><ul><li><code>ROWS BETWEEN</code>: يعتبر كل صف منفصل بغض النظر عن القيم المتكررة (أكثر استخدامًا ودقة).</li><li><code>RANGE BETWEEN</code>: يعامل الصفوف ذات القيم المكررة في عمود الترتيب ككيان واحد.</li></ul><hr><h2>خلاصة</h2><p>دوال النوافذ في PostgreSQL توفر طرقًا قوية ومرنة لتحليل البيانات ضمن مجموعات وصفوف ذات صلة، مما يسهل إجراء تحليلات معقدة مثل الترشيح التراكمي، التصنيف، وتحليل الاتجاهات بسهولة عالية. استخدام هذه الدوال يسمح لمحللي البيانات والمطورين بتحقيق استغلال متميز لبياناتهم.</p>"
}
]

